<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<title>rtl-sdr and GNU Radio w/Realtek RTL2832U, E4000 and R820T</title>
	<link rel="stylesheet" type="text/css" href="/meh.css" />
	<link rel="webmention" href="http://superkuh.com/webmention" />
</head>


<!-- Hi. Anything I've commented out is probably new and uncomfirmed, outdated, or turned out to be wrong. -->
<body>

<!-- This is b0t link bait so I can train my log parser more accurately.
<a href="/iamab0t.html">I am a b0t who randomly follows all links.</a>
-->

<div id="center" class="column">


<div style="float:right;margin-left:1em;"><h5>Last updated: 2020-05-23 - <a href="https://github.com/torvalds/linux/commit/2bef9aed6f0e22391c8d4570749b1acc9bc3981e">kernel fix for libusb when it attempts
to create zero-copy buffers for use by rtl-sdr</a></h5></div>
<!-- MENU USED TO BE HERE -->


<h1>RTL-SDR and GNU Radio with Realtek RTL2832U [Elonics E4000/Raphael Micro R820T] software defined radio receivers.</h1>

<a name="intro">

<a href="http://erewhon.superkuh.com/gnuradio/dx_EzTV668_1v1.jpg"><img src="http://erewhon.superkuh.com/gnuradio/dx_EzTV668_1v1_sm.jpg"></a><br />
<a href="http://erewhon.superkuh.com/gnuradio/rtlsdr_QS_FSC_USB_DVB-T.jpg"><img src="http://erewhon.superkuh.com/gnuradio/rtlsdr_QS_FSC_USB_DVB-T_sm.jpg" /></a>
<p>Originally meant for television reception and streaming the discovery and exploitation of the separate raw mode used in FM reception was perhaps first noticed by <a href="http://comments.gmane.org/gmane.linux.drivers.video-input-infrastructure/30346">Eric Fry in March of 2010</a> and then expanded upon by <a href="http://thread.gmane.org/gmane.linux.drivers.video-input-infrastructure/44461/focus=44461">Antti Palosaari in Feb 2012</a> who found that these devices can output unsigned <a href="http://cgit.osmocom.org/cgit/gr-osmosdr/tree/lib/rtl/rtl_source_c.cc#n167">8bit I/Q samples</a> at high rates.</p>

<!--As of 2017 using the RTL2832U explicitly for SDR is mainstream and a significant driver of chip production.-->

<p>The drivers and userspace tools that made rtlsdr what it is today were created by the <a href="http://sdr.osmocom.org/trac/wiki/rtl-sdr">osmocom people</a>,</p>

<ul>
<li>librtlsdr -  contains the major part of the driver</li>
<li>rtl_sdr, rtl_tcp, rtl_test, etc -  command line capture tools and utilities</li>
<li>gr-osmosdr - gnuradio <!--3.6-->compatible module</li>
<li>and a bunch of other stuff.</li>
</ul>

<p>keenerd is the author of many other rtl_* tools: rtl_fm, rtl_power (heatmap.py), rtl_adsb and code changes accepted into the mainline.<!-- He recently (August 2014) finished a successful <a href="https://www.indiegogo.com/projects/a-month-of-rtl-sdr/x/8237392">fundraiser on indiegogo</a> to dedicate time to add new features, port interesting modifications by others, and work on rtl-sdr and the rtl_* tools. --></p>

<p>patchvonbraun is the author and maintainer of the <a href="#installing">build-gnuradio script</a> that made it easy for me, and multitudes of others, to get started with rtlsdr under GNU Radio.</p> 


<p><a href="http://rtl-sdr.com/">rtl-sdr.com</a> has the latest news and tutorials. <a href="http://rtlsdr.org">rtlsdr.org</a> has a clear introduction too.</p>

<h4>RF, DSP, and USB details</h4>

<!--<p>The dongles with an E4000 tuner can range between 54-2147 MHz (in my experience) with a gap over 1100-1250 MHz in general. The R820T and R820T2 go from 24-1760 MHz (but with reduced performance above 1500 MHz). The R820T use a 3.57MHz intermediate frequency (IF) to one RTL2832U ADC pin while the E4000s use a Zero-IF and two RTL2832U ADC pins. Non-SDR specific kinds have a tuner error of ~30 +-20 PPM, relatively stable once warmed up, and stable from day to day for a given dongle. All of the antenna inputs are 75 Ohm impedance. The dynamic range for most dongles is around 45 dB. The highest safe sample rate is 2.56 MS/s but <a href="http://www.reddit.com/r/RTLSDR/comments/1r5d6l/32_mss_on_usb_30_ports_without_lost_samples/">in some situations</a> up to 3.2 MS/s works without USB dropping samples (RTL2832U might drop them internally). Because the devices use complex sampling (I/Q) the sample rate is equal to the bandwidth instead of just half of it. For the data transfer mode USB 2 is required, 1.1 won't work. Antti Palosaari's <a href="http://blog.palosaari.fi/2013/06/naked-hardware-11-unbranded-rtl2832u.html">measurements</a> show the R820T use ~300mA of 5v USB power while the E4000 devices use only ~170mA. You can cut the leads to the LED to drop usage ~10%.</p>
-->

<p>The dongles with an E4000 tuner can range between 54-2147 MHz (in my experience) with a gap over 1100-1250 MHz in general. The R820T and R820T2 go from 24-1760 MHz (but with reduced performance above 1500 MHz).<!--The R820T use 3.57 MHz intermediate frequency IF for the DVB-T 6 MHz mode and 4.57 MHz for the 8 MHz mode while the E4000s use a differential Zero-IF.--> The R820T dongles use a 3.57 MHz or 4.57 MHz intermediate frequency (IF) while the E4000s use a Zero-IF<!--and both RTL2832U ADC-->. For both kinds the tuner error is ~30 +-20 PPM, relatively stable once warmed up, and stable from day to day for a given dongle. All of the generic dongle antenna inputs are 75 Ohm impedance (some SDR branded versions have 50 ohm input). The RTL2832 ADC differential input impedance is ~3,300 Ohm. The dynamic range for most dongles is around 45 dB. The sensitivity is somewhere around -110 dBm typically. The highest safe sample rate is 2.56 MS/s but <a href="http://www.reddit.com/r/RTLSDR/comments/1r5d6l/32_mss_on_usb_30_ports_without_lost_samples/">in some situations</a> up to 3.2 MS/s works without USB dropping samples (RTL2832U drops them internally). Because the devices use complex sampling (I/Q) the sample rate is equal to the bandwidth instead of just half of it. For the data transfer mode USB 2 is required, 1.1 won't work. Antti Palosaari's <a href="http://blog.palosaari.fi/2013/06/naked-hardware-11-unbranded-rtl2832u.html">measurements</a> show the R820T use ~300mA of 5v USB power while the E4000 devices use only ~170mA. You can cut the leads to the LED to drop usage ~10%.</p>

<p>The rtlsdr RTL2832U chips use a phased locked loop based synthesizer to produce the local oscillator required by the quadrature mixer. The quadrature mixer produces a complex-baseband output where the signal spans from -bandwidth/2 to +bandwidth/2 and bandwidth is the analog bandwidth of the mixer output stages. (<a href="#links">Datasheets</a>, general refs: <a href="https://www.youtube.com/watch?v=spUNpyF58BY">But what is the Fourier Transform? A visual introduction</a> by 3Blue1Brown, <a href="http://erewhon.superkuh.com/library/Electromagnetics/Software%20Defined%20Radio/Quadrature%20Signals_%20Complex,%20But%20Not%20Complicated_%20Richard%20Lyons_%202008.pdf">Quadrature Signals: Complex, But Not Complicated</a> by Richard Lyons) This is complex-sampled (I and Q) by the ADC. The Sigma-Delta ADC samples at some high rate but low precision. From this a 28.8 Msps stream at 8 bits is produced. That can be resampled inside the RTL2832U to present whatever sample rate is desired to the host PC. This resampled output can be up to 3.2 MS/s but 2.56 MS/s is the max recommended to avoid losing samples. The minimum resampled output is 0.5 MS/s. Check <a href="http://www.reddit.com/r/RTLSDR/comments/1uazsw/rtl2832_datasheet_deep_info/cegj1qo">this reddit thread</a> for caveats and details. The actual output is interleaved; so one byte I, then one byte Q with no header or metadata (timestamps). The samples themselves are unsigned and you subtract 127 from them to get their actual {-127,+127} value. You'll almost certainly notice a stable spike around DC. It's from either the 1/f noise of the electronics or if it's a Zero-IF tuner (E4000) the LO beating with itself in the mixer.<!-- If all I and Q samples from a spectrum are averaged the result from each should be 0. To remove the bias measure it empirically then add that constant to the 127 you normally subtract. If it is 0.39, then subtract 127.39.--></p>
<!--<pre>iq = [complex(i/(255/2) - 1, q/(255/2) - 1) for i, q in izip(bytes[::2], bytes[1::2])]</pre>-->


<h4>Popular software</h4>

<p>My favorite way to explore the spectrum is using <a href="http://kmkeen.com/rtl-power/">rtl_power</a> to do very wideband multi-day surveys. For general use <a href="http://sdrsharp.com/">SDR#</a> is probably the best application for windows with secondary <a href="#sdrsharpappnote">mono-based linux</a> and Mac support. I normally use <a href="http://gqrx.dk/download">Gqrx</a> but it requires GNU Radio dependencies. Luckily there are Linux and OS X native binaries packages with all dependencies (ie, gnuradio) these days. For doing diagnostic and low signal level work <a href="http://www.sm5bsz.com/linuxdsp/linrad.htm">Linrad</a> is full featured and fast. <a href="http://sdr.osmocom.org/trac/wiki/GrOsmoSDR#SpectrumBrowser">osmocom_fft</a> comes with GNU Radio module gr-osmosdr and is the natural and best way to use <a href="http://sdr.osmocom.org/trac/wiki/fosphor">gr-fosphor</a>; a GPU accelerated display.

<!-- In the far past, and once again since mid-Sept. 2015 it's possible to <a href="#sdrsharpappnote">run it under Mono on linux</a>.->
<!--you'll have to compile from svn for linux+mono because of some non-portable mono ifdef's during building-->
 <!-- but since the DSP source went closed there's no linux availability.--> 

<!--<a href="https://github.com/csete/gqrx">gqrx</a> for <a href="http://dekar.wc3edit.net/2012/09/30/osx-port-of-the-awesome-gqrx-sdr-software/">OSX</a> (<a href="http://inst.eecs.berkeley.edu/~ee123/fa12/rtlsdr/rtlsdr_osx.zip">precompiled</a>) or linux.--> <a href="https://www.cgran.org/svn/projects/multimode">multimode</a> has a very full and configurable GUI (it works great with GPU accelerated displays like gr-fosphor). For command line and low power devices try keenerd's <a href="http://kmkeen.com/rtl-demod-guide/">rtl_fm</a>.<!-- In the past stevem has <a href="http://steve-m.de/projects/rtl-sdr/openwrt/">provided</a> rtlsdr and related tools for openwrt and others made various cell phone ports.--></p>
<!-- but revisions after ~800 probably require compiling it yourself (if on linux) instead of using precompiled binaries. I'm <a href="/sdrsharperrors.txt">having troubles</a> so far, but older revisions are great.</p> -->

<p>These sites maintain the best list of rtlsdr device supporting applications: <a href="https://sdr.osmocom.org/trac/wiki/rtl-sdr#KnownApps">https://sdr.osmocom.org/trac/wiki/rtl-sdr#KnownApps</a>, <a href="https://sdr.osmocom.org/trac/wiki/GrOsmoSDR#KnownApps">https://sdr.osmocom.org/trac/wiki/GrOsmoSDR#KnownApps</a>, and lately <a href="http://www.rtl-sdr.com/big-list-rtl-sdr-supported-software/">http://www.rtl-sdr.com/big-list-rtl-sdr-supported-software/</a></p>


<p>Assuming you're on linux, but applicable in general, do not use the OS DVB drivers. Those are for the  DVB-T mode and not the debug mode that outputs raw samples. Linux 3.x kernel should check with "$ lsmod | grep dvb_usb_rtl28xxu" and if found at least "$ sudo modprobe -r dvb_usb_rtl28xxu" to unload it.<!-- Be careful about mixing gnuradio versions; they may leave behind problem files.--></p>

<!--<a href="http://erewhon.superkuh.com/r820t8.png"><img src="http://erewhon.superkuh.com/rtl_power_sm.png"/></a><br />-->
<p>While the sampling bandwidth is only 2.56 MHz the frequency can be re-tuned up to ~40 times a second. With frequency hopping you can survey very large bandwidths. See tholin's annotated <a href="http://erewhon.superkuh.com/tholin_rtlsdr.png">24 hour rtl_power spectrogram</a>. Below is a zoomable 37200*31008 pixel 5 day long spectrogram I made using rtl_power's FFT mode and heatmap.py. It starts very far zoomed out. It might load a bit slow too. (<a href="http://ironpants.superkuh.com/radio/2014-08-26_17-55_70-1000_25k/">view full window</a>)</p>

<iframe style="width:100%;height:300px;" src="/radio/2014-08-26_17-55_70-1000_25k/"></iframe>

<hr />

<p>This page is mostly just notes to myself on how to use rtlsdr's core applications, 3rd party stuff using librtlsdr and wrappers for it, and lots on using the gr-osmosdr source in GNU Radio and GNU Radio Companion. This isn't a "blog", don't read it sequentially, just search for terms of interest or use the topics menu. For realtime support on the same topics try Freenode IRC's ##rtlsdr and reddit's r/rtlsdr. <!-- They put up with lots of ignorant questions but please do not visit if you're going to be a <a href="http://slash7.com/2006/12/22/vampires/">help vampire</a>. --><!--The GUI flowchart interface for making receivers is fairly easy to pick up but not required if a python file is included.--></p><!--<br clear="all" />-->

<hr />

<a href="/gnuradio/rtlsdr_r820t_mini_2.jpg"><img style="float:left;margin-right:1em;" src="http://erewhon.superkuh.com/gnuradio/rtlsdr_r820t_mini_float.jpg" /></a>

<!--
<a href="http://erewhon.superkuh.com/gnuradio/dongletocoax.jpg"><img src="http://erewhon.superkuh.com/gnuradio/dongletocoax_sm.jpg" /></a>
<a href="http://erewhon.superkuh.com/gnuradio/ezcap_ant_connector.jpg"><img src="http://erewhon.superkuh.com/gnuradio/ezcap_ant_connector_sm.jpg"></a>
-->

<a name="hardware">

<p>These days for most people doing most things you want to get an dongle with an R820T2 tuner. They'll come with MCX coaxial connectors. On sites like eBay shipping from China the average price is about ~$10 shipped. These work fine for most things. At a bit higher price of ~$20 some come with improvements like SMA or F connectors, metal cases and heatsinks on the tuner for stability above 1500 MHz, temperature controlled crystal oscillators, extra breakouts on the PCB, and the like.

<p>I bought two E4000 based rtlsdr usb dongles for $20 each in early 2012. Then many months later I bought two more R820T tuner based dongles for ~$11 each.<!-- Of the E4Ks the Newsky TV28T (yellow) was from ebay and arrived within two weeks, well before the DealExtreme dongle arrived. The (green) ezcap EzTV668 was from DealExtreme, payed for on March 25th (2012) and delivered on May 20th.--> There's photos of the E4ks up at the top of the page and of an R820T based dongle in the "mini" format off to the left (most minis do not have eeproms for device ID). It and the Newsky E4k dongle up top are MCX. <!--I used to think the Newsky TV28T was missing a protection diode U1 (reddit thread on <a href="http://www.reddit.com/r/RTLSDR/comments/tl187/tuner_protection_diodes/">protection diode replacements</a>) but apparently it is just very, very tiny (0203 sized or smaller).--> Back in 2012 some of the cheaper dongles occasionally miss protection diodes but that is no longer an issue. The antenna connector on the E4k ezcap up top is IEC-169-2, Belling-Lee. I usually replace it with an F-connector or use a PAL Male to F-Connector Female. F to MCX for the other style dongles. The default design has the tuner taking 75 Ohm so that's what they all are except SMA.</p>

<a name="tuners">
<h3>Tuners</h3>

<pre>RTL-SDR Tuner Type	Frequency Range

Elonics E4000 (E4K)	54 - 2200 MHz (1100 MHz-1250 MHz gap)
Rafael Micro R820T	24 - 1766 MHz (>1500 MHz is bad w/o tuner cooling)
Rafael Micro R820T2	24 - 1766 MHz (>1500 MHz is bad w/o tuner cooling)
Rafael Micro R820T2 	13 - 1864 MHz (<a href="https://github.com/mutability/rtl-sdr/">mutability's driver</a>)
Fitipower FC0013	22 - 1100 MHz (FC0013B/C, FC0013G has seperate L band input)
Fitipower FC0012	22 - 948 MHz
FCI FC2580		146 - 308 MHz and 438 - 924 MHz</pre>

<p>Only three tuners are very desirable at this time. The Elonics E4000 and the Raphael Micro R820T/R820T2. In general they are of equal performance but the sticks with R820T2 chips are easy to find, cheaper (~$10 USD), and they have a smaller DC spike due to the use of a non-zero intermediate frequency but must have cooling for the tuner to PLL lock above ~1500 MHz or so. The E4K is better for high end (&gt;1.7GHz) while the R820T can tune down to 13 MHz without any hardware mods (mutability's driver). <!--According to <a href="http://www.reddit.com/r/RTLSDR/comments/1l2vlx/my_tests_indicate_the_e4000_dongles_retune_twice/">my tests</a> the E4000 based dongles are almost twice as fast at retuning as the R820T.--> The tuners themselves are set up and retuned with I2C commands. E4000 tuners used to re-tune twice as fast as R820T tuners, but this was fixed in <a href="#keenerdappnote">keenerd's experimental branch</a> where R820T actually tune a tiny bit faster than the E4Ks. These changes were later adopted by the main rtlsdr.</p>

<a name="tuners.retunespeed">
<h5>Re-tune speed</h5>

<p>But that was the old days when rtlsdr sticks re-tuned relatively slowly. As time passed re-tuning speed has been increased by clean-ups in code and specifically keenerd's changes so the tuner doesn't wait nearly as long for the pll to settle. More recently tejeez's mod made the re-tuning even faster by updating all the changed registers for a re-tune in one r82xx_write I2C call. With this done you can re-tune at rates of up to 41(!) hops per second; a ~2x improvement over then-existing drivers. Since then all of these re-tuning changes have been incorporated into the main rtlsdr. <!--The <a href="http://erewhon.superkuh.com/tholin_rtlsdr.png">wide bandwidth spectrograms</a> tholin has created with this modification look amazing. --> <!-- Grab a copy of the tejeez modified rtlsdr source from <a href="http://prk-12.prk.tky.fi/~peltolt2/?C=M;O=D">his website</a> directory listing. --></p>

<p>Further massive speed-ups can be had at the cost of pretty much all reliability. By not waiting for PLL lock at all and always leaving the i2c repeater register enabled tejeez reports retuning speeds of up to 300 jumps per second are possible.</p>


<a name="tuners.tuningrange">
<h5>Tuning range</h5>

<p>As of Aug. 2014 a handful of people have found ways to extend the r820t frequency range as well. <!--Stefan Sydow of <a href="https://github.com/stsydow/rtl-sdr">https://github.com/stsydow/rtl-sdr</a>--> Initially thought to top out at 1700 MHZ the R820T driver has has re-written to tune from 22 to 1870(!) MHz. While efforts have been made to extend the lower range as well, with the PLL seeming to lock down to 8 MHz in some cases, this range turns out to be full of images and repeats of the higher frequency range. A later effort with the addition of <a href="http://lists.osmocom.org/pipermail/osmocom-sdr/2014-August/001353.html">driver tweaks to the RTL2832 downconverter</a> pushed the low end down to ~15 MHz. The code is at <a href="https://github.com/mutability/rtl-sdr/">https://github.com/mutability/rtl-sdr/</a>.</p>

<p>After tejeez worked out the no-mod HF reception a couple people have noted that the tuners with fc0013 receive HF even better than the R820T board designs. So if you have one of those laying around you might want to try HF with it.</p>

<a name="tuners.gain">
<h5>Gain settings</h5>

<p class="quote">The E4K has settings for LNA (-5..+25dB), mixer (4 or 12dB) and total of 6 IF gain stages with various gains allowing for 1dB steps between 3 and 57dB. The software only deals with LNA and mixer gain and not independently. IF gain can be set through the API.</p>

<p class="quote">R820T also has LNA, mixer and IF gain settings - the exact steps are not known. The numbers in the library code are through measuring the gain at a fixed frequency. That gave 0..33dB for the LNA, 0..16dB for the mixer and -4.7..40.8dB for the IF gain. The current library does not expose
these settings through an API, only LNA and mixer are set through some algorithm. IF gain is set to a fixed value.</p>

<p>bofh__ gives more detail about the R820T step size,</p>
<p class="quote">The mixer gain step is 1dB (matches the empirical data passably, but not great) and the IF/VGA gain step is 3.5dB (matches mine basically dead-on). LNA gain step is not mentioned, all it says is "1111 - max, 0000 - min"</p>

<a name="tuners.frequencyerror">
<h5>Frequency error</h5>

<p>All of the dongles have significant frequency offsets from reality that can be measured and corrected at runtime. My ezcap with E4000 tuner has a frequency offset of about ~44 Khz or ~57 PPM from reality as determined by checking against a local 751 Mhz LTE cell using <a href="#ltescanner">LTE Cell Scanner</a>. Here's a <a href="/gnuradio/live/ppmerror_751600000.png">plot of frequency offsets in PPM</a> over a week. The major component of variation in time is ambient temperature. With the R820T tuner dongle after correctly for I have has a ~ <a href="/gnuradio/kalibrate-rtl_install_example_notes.txt">-17 Khz offset at GSM frequencies</a> or  -35 ppm absolute after applying a 50 ppm initial error correction. When using kalibrate for this the initial frequency error is often too large and the FCCH peak might be outside the sampled 200 KHz bandwidth. This requires passing an initial ppm error parameter (from LTE scanner) -e . Another tool for checking frequency corrections is <a href="https://github.com/keenerd/rtl-sdr">keenerd's version of rtl_test</a> which uses (I think) ntp and system clock to estimate it rather than cell phone basestation broadcasts.</p>

<p>Also very cool is the <a href="http://www.haystack.mit.edu/edu/undergrad/srt/index.html">MIT Haystack</a> people <a href="http://www.haystack.mit.edu/edu/undergrad/srt/pdf%20files/2013_HigginsonRollinsPaper.pdf">switching to rtlsdr dongles</a> (pdf) for their SRT and VSRT telescope designs, <a href="http://www.haystack.mit.edu/edu/undergrad/VSRT/VSRT_Memos/071.pdf">Use of DVB-T RTL2832U dongle with Rafael R820T tuner</a> (pdf). The first of these characterizes the drift of the R820T clock and gain over time as well as a calibration routine.</p>

<p>As of 2015 there are a number of SDR-enthusiast targeting dongles produced with temperature controlled oscillators (TXCO) that run at less than 1 PPM with no start-up drift.</p>


<a name="tuners.r820t2">
<h5>R820T2 variant</h5>

<p>I recently (06-15-2014) found out from prog (of SDR# and airspy) that there are actually two different versions of the R820T tuner. The normal one and the R820T2. The T2 has <a href="/r820t_t2_filters.png">different intermediate frequency filters</a> allowing for wider IF bandwidths and apparently slightly better sensitivity (a few dB lower noise floor?). For rtlsdr dongles this difference in IF filter bandwidth usually doesn't matter much since all of them are larger than the RTL2832U's debug/SDR mode bandwidth of ~3 MHz. But there are certain situations where a larger tuner bandwidth is advantageous: such as when using <!--<a href="http://lists.osmocom.org/pipermail/osmocom-sdr/2014-August/001353.html">--><a href="https://github.com/mutability/rtl-sdr/">Jowett's HF tuning mod</a>. As of Sept. 2014 some of the new R820T2 have been showing up in Terratec "E4000 upgrade" model sticks. But don't count on it. I bought one from ebay seller "smallpartsbigdifference" which had a <em>photo showing an R820T2</em> and it was just an R820T. Since ~2015 R820T2 have become far more available. Here's a pdf with the <a href="/R820T2_Register_Description.pdf">R820T2 Register Descriptions</a>.</p>

<p>As of 2017-12-11 Rafael Micro has been sending out emails saying the R820T2 has been discontinued. Alternate versions of the series, not pin compatible, are the R836, R840, or R828D. I've already seen SDR-targeted dongles using the R828D.</p>

<p>As of March 2018 it's uncertain how many non-defect bin R820T2 tuners Rafael Micro has left but rtlsdrblog has said that if very large bulk orders could be made Rafael Micro might be willing to produce more.</p>


<a name="tuners.r820tiffilter">
<h5>R820T/2 IF Filter Settings</h5>

<p>In Feburary 2015 Leif sm5bsz (of linrad) <a href="http://lists.osmocom.org/pipermail/osmocom-sdr/2015-February/000019.html">relased a modified librtlsdr</a> with changes to the rtlsdr R820T tuner code to allow for finer grained control over IF filter settings.</p>

<p class="quote">The IF filter which
actually is a low pass filter and a high pass filter
can be set for a bandwidth of 300 kHz. Dynamic range
increases by something like 30 dB for the second next 
channel 400 kHz away. It is also possible to get some
more improvement by changing the gain distribution.</p>

<p>Following this gat3way's <a href="https://www.reddit.com/r/RTLSDR/comments/2uogkp/grosmosdr_patched_to_use_leifs_librtlsdr_to_use/">patched gr-osmosdr</a> and Vasili_ru's <a href="http://www.rtl-sdr.com/new-sdr-rtl-sdr-driver-lnamixervga-gain-settings-decimation/">SDR# driver</a> were released. gat3way made the IF filter width variable from within gqrx by presenting it as a gain value. Vasili's rtlsdr SDR# driver also moves the SDR# decimation normally applied during demodulation to the front of the IQ stream. This gives better dynamic range for the visual FFT but demodulated quality is not changed. <!--It is my understanding that much if this is inspired by the released <a href="https://github.com/airspy/firmware/blob/master/common/r820t.c#L695">Airspy r820t2 tuning code</a>.--> So far this is all experimental but expect it to be brought mainline on both sides soon.</p>

<p>keenerd's experimental branch automatically set IF filter width based on sample rate but had not exposed them as manually set values.</p>


<a name="tuners.r828d">
<h5>R828D variant</h5>

<p>In late 2013 Astrometra DVB-T2 dongles with the R828D tuner (<!--<a href="http://steve-m.de/pictures/rtl-sdr/rtl2832p_dvbt2/02_rtl2832p_dvbt2.jpg">--><a href="/02_rtl2832p_dvbt2.jpg">pic</a>) paired RTL2832U have begun to <a href="http://www.ebay.com/itm/New-USB-2-0-DVB-T2-HDTV-Digital-TV-Stick-Remote-Recorder-Receiver-DVB-C-DV-ESY1-/121174868976?pt=US_Video_Capture_TV_Tuner_Cards&hash=item1c3695c3f0">appear</a> (<a href="http://blog.palosaari.fi/2013/10/naked-hardware-14-dvb-t2-usb-tv-stick.html">2</a>). The DVB-T2 stuff is done by a separate Panasonic chip on the same I2C bus. merbanan wrote a set of patches, <a href="https://github.com/merbanan/rtl-astrometa">rtl-astrometa</a>, for librtlsdr has better support these tuners. The performance hasn't been characterized but it at least works for broadcast wide FM via SDR. steve|m's preliminary testing suggests bad performance in the form of the crystal for the DVB-T2 demodulator leaking fixed spurs 25 dB above noise floor in the IF at approximately 196 and -820 KHz. He was able to mitigate these with the hardware mod of removing the crystal for the DVB-T2 chip (<a href="http://www.reddit.com/r/RTLSDR/comments/1pyz9l/new_rtlsdr_rafael_r828d_tuner_in_the_works/cd88ajc?context=3">ref</a>). Official support was added to the rtl-sdr on <a href="http://cgit.osmocom.org/rtl-sdr/commit/?id=aefd8b7d58c4735b19110b5f54de289e8dd931f5">Nov 5th</a> while testing support was added on <a href="http://cgit.osmocom.org/rtl-sdr/commit/?h=testing&id=00d567f59b8bf465253c7da355bc55197e54cdd9">Nov 4th</a>. In April 2017 u/strangerwithadvice on reddit made a quality post on the r/rtlsdr subreddit where he <a href="https://www.reddit.com/r/RTLSDR/comments/643f6v/r828d_testing/">characterized the noise floor of an R828D dongle</a> stock and with a number of modifications to reduce noise.</p>

<a name="tuners.fc0013">
<h5>Double FC0013 tuner PCI DVB card</h5>
<p>randomsdr reported on Freenode ##rtlsdr IRC on 2015-09-03 that the Leadtek Winfast DTV2000DS PLUS <b>pci card</b> has 2x FC0013 tuners and 2x rtl2832u chips like 2 normal rtlsdr dongles. Performance is not good but tools like rtl_fm work if the VID/PID is added to the rtlsdr driver table and udev rules set. It isn't recommended except as a novelty.</p>

<a name="tuners.e4000">
<h5>E4000 datasheet</h5>

<p>2012-08-22: The E4000 tuner datasheet has been <a href="http://lists.osmocom.org/pipermail/osmocom-sdr/2012-August/000238.html">released into the wild</a>. <a href="http://www.superkuh.com/gnuradio/Elonics-E4000-Low-Power-CMOS-Multi-Band-Tunner-Datasheet.pdf">Elonics-E4000-Low-Power-CMOS-Multi-Band-Tunner-Datasheet.pdf</a>, but...</p>
<p class="quote">"All the ones that are documented in the DS are 'explained'in the driver header file ... And the rest, the datasheet call them "Ctrl2: Write 0x20 there"  and no more details"</p>

<h5>R820T original, support, etc</h5>

<p>2012-09-07: Experimental support for dongles with the <a href="http://www.rafaelmicro.com/products.htm">Rafael Micro R820T</a> tuner that started appearing in May has been <a href="http://lists.osmocom.org/pipermail/osmocom-sdr/2012-September/000253.html">added to rtl-sdr source base</a> by stevem. These tuners cover 24 MHz to 1766 MHz. They also don't have the DC spike caused by the I/Q imbalance since they use a different, non-zero, IF. On the other hand, they might have image aliasing due to being superheterodine receivers. See <a href="http://rof.li/pic/tuner_comparison/">stevem's tuner comparisons</a>. On 2012-09-20 the <a href="/gnuradio/R820T_datasheet-Non_R-20111130_unlocked.pdf">R820T datasheet</a> was <a href="https://groups.google.com/forum/#!topic/ultra-cheap-sdr/4oVYR34jqgg">leaked to the ultra-cheap-sdr mailing list</a>. The <a href="/R820T2_Register_Description.pdf">R820T2 Register Description</a> pdf was provided by luigi tarenga to the ultra cheap sdr mailing list after he received it from RafaelMicro. The official range is 42-1002 Mhz with a 3.5 dB noise figure. On 2012-10-04 my order arrived. I'm liking this tuner very much since it actually works well, locking down to 24 Mhz or so *without* direct sampling mode. Here's a rough gnuplot <a href="http://superkuh.com/1300mhzierd.png">spectral map of 24 to 1700 Mhz over 3 days</a> I made with some custom perl and python scripts. Don't judge the r820t on the quality of that graph, it is just to show the range. You can see what I think is either front-end mixer filters not attenuating enough or actual intermodulation as RFI. I do almost no processing of the signal (ie, no IQ correction), don't clear the buffer between samples (LSB probably bad), and use a hacky way to display timeseries data in gluplot. Real SDR software like SDR# shows them to be equal or better in quality to E4ks.<!--Gain control is automatic unless there is a voltage applied between vcc and pin 14. The max gain is +48 dB.--></p>

<p>stevem did <a href="http://steve-m.de/projects/rtl-sdr/gain_measurement/">gain measurement tests</a> with a few dongles using some equipment he had to transmit a GSM FCCH peak, "which is a pure tone." This includes the <a href="http://steve-m.de/projects/rtl-sdr/gain_measurement/e4000/">E4000</a> and <a href="http://steve-m.de/projects/rtl-sdr/gain_measurement/r820t/">R820T</a> tuners. In addition he measured the <a href="http://steve-m.de/projects/rtl-sdr/gain_measurement/r820t/mixer/">mixer</a>, <a href="http://steve-m.de/projects/rtl-sdr/gain_measurement/r820t/if/">IF</a> and <a href="http://steve-m.de/projects/rtl-sdr/gain_measurement/r820t/lna/">LNA</a> for the R820T.</p>
<!-- By listening in while it was discussed on IRC read they can be interpeted as "roughly linear" with" ~1dB/bit because of a minute timescale slow oscillation in gain cycling up and slowly down 1 dB.--> 

<!-- <p>W6KAP later posted his R820T tests on the frequency variation of the <a href="http://groups.yahoo.com/group/rtlsdr/message/481">stability in RF gain and the level needed to overload</a>.</p> -->


<a name="directsample">
<h3>High Frequency (0-30Mhz) Direct Sampling Mod</h3>

<a href="http://erewhon.superkuh.com/gnuradio/dx_EzTV668_1v1_shortwave-connection-point.jpg"><img style="float:left;margin:1em;" src="http://erewhon.superkuh.com/gnuradio/dx_EzTV668_1v1_shortwave-connection-point_sm.jpg" /></a>
<p>Steve Markgraf of Osmocom has <a href="http://cgit.osmocom.org/cgit/rtl-sdr/commit/?id=fc5881d4cd6f778b080a3008dbcf4157ae1e13a2">created an experimental software and hardware modification</a> to receive 0~30Mhz(*) by using the 28.8 MHz RTL2832U ADCs for RF sampling and aliasing to do the conversion. In practice you only get DC-14.4MHz in the first Nyquist zone but the upper could be had by using a 14.4 MHz to 28.8 MHz bandpass filter. In the stereotypical ezcap boards you can test this by connecting an appropriately long wire antenna to the right side of capacitor 17 (on EzTV668 1.1, at least) that goes to pin 1 of the RTL2832U. That's the one by the dot on the chip surface. Apparently even pressing a wet finger onto the capacitor can pick up strong AM stations. This bypasses static protection among other things so there's a chance of destroying your dongle. For gr-osmosdr the parameter direct_samp=1 or direct_samp=2 gives you the two I or two Q inputs. <!--e4000 tuner only needs this?--></p> 

<h4>No hardware change, software mod direct sampling</h4>

<p><!--With R820T dongles-->It has recently become possible to use direct sampling with no hardware modifications at all. It is still very experimental and performance is bad. In Oct 2012 <a href="http://www.reddit.com/r/RTLSDR/comments/12d2wc/a_very_surprising_discovery/">Anonofish on the r/rtlsdr subreddit had discovered</a> the PLL would lock for a small ~ 3686.6 MHz - 3730 MHz range far outside the normal tuning range and there seemed to be signals there. In January 2014 ##rtlsdr IRC channel user tejeez figured out this bypassed the tuner (mixer leakage) and implemented a set of register settings (R820T IF frequency, IF filter bandwidths, r82xx_write_reg_mask(priv, 0x12, val, 0x08) replaced with r82xx_write_reg_mask(priv, 0x12, val|0x10, 0x18)) that would exploit this to enable HF reception. Shortly thereafter keenerd assembled everything into a relatively easy to use patch-set.</p>

<p>If you want to give HF listening a try with no risk keenerd has added these changes rtl_fm and rtl_power in his <a href="https://github.com/keenerd/rtl-sdr/">experimental rtlsdr repository</a>. To use the no mode mode with rtl_ tools append the argument, "-E no-mod".<!-- Alternately a static copy of the modified rtlsdr code is availble from tejeez himself at <a href="http://prkele.prk.tky.fi/~peltolt2/rtl-sdr-nomod2.tar.gz">http://prkele.prk.tky.fi/~peltolt2/rtl-sdr-nomod2.tar.gz</a>.--> To use the no-mod direct sampling in something that uses gr-osmosdr, like gqrx or GRC flowgraphs, add the following to the the "device string" parameters: ie "direct_samp=3". Plug your HF antenna into the normal connector, no hardware mods needed.</p>

<!--  With direct sampling, you're just using one side of the ADC on the RTL2832U chip as a direct RF sampler, without and up/downconversion stage. You ignore the tuner. -->

<br clear="all" />

<h5>Differential input</h5>


<img src="http://erewhon.superkuh.com/rtl2832u-pins.jpg" /><img src="http://erewhon.superkuh.com/rtlsdrmini-pins.jpg" />

<p>I've been told my pin numbering doesn't correspond to the datasheets, so take that with salt. The relative positions are correct regardless of the numbering. The RTL2832 ADC differential input impedance is ~3,300 Ohm.</p>

<img src="/rtl2832u-pins.png"><br/>

<p>A number of people have tried to match the ADC's input impedance and both differential inputs by using baluns of various sorts. The datasheet seemed to say 200 Ohm so a lot of people (myself included) tried 4:1 baluns which did improve performance. But better matches can be found using the 1800 Ohm (36:1) Mini-circuits T36-1-KK81 with a 3900 Ohm resistor in parallel with the secondary to bring the RTL impedance down to 1800 Ohm (ref: <a href="http://www.g8jnj.net/softwaredefinedradio.htm">G8JNJ</a>).</p>

<a href="http://dekar.wc3edit.net/2012/11/07/rtl2832u-transformer-mod/">Dekar has a page</a> showing how to use an ADSL transformer to generate signal for the ADCs differential input <em>using pin 1 (+I) and 2(-I)</em> on the RTL2832. <a href="http://yu3ma.net/wp/">mikig</a> has a useful <a href="http://yu3ma.net/wp/wp-content/uploads/2012/08/rtl2832u-dc-mods.pdf">pdf schematic</a> with part numbers for using wide band transformers or toroids for winding your own.  Here's a series of posts from bh5ea20tb showing how to <a href="http://translate.googleusercontent.com/translate_c?depth=1&hl=en&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&tl=en&twu=1&u=http://blog.livedoor.jp/bh5ea20tb/archives/4263275.html&usg=ALkJrhgLmwI_smaNpGedLvdkZHK93RCiLg">use a FT37-43 ferrite core</a>. And another <a href="http://hamradio.selfip.com/i6ibe/rtl2832hf/dongle.htm">example</a> from IW6OVD Fernando. <a href="http://www.qsl.net/py4zbz/hfrtl.htm">PY4ZBZ</a> as well. The ADC has a differential/balanced input so this is done mainly for the unbalanced-&gt;balanced conversion. But the ADC input pins also have a DC offset so you can't just connect one to GND for that. <!--Impedance matching can be done as well but the impedance isn't known. A recent study suggested it was near 3 KOhm but ~200 Ohms seems reasonable and is mentioned in some of the tuner datasheets. 4:1 baluns that are used for cable-tv might also work, depending on the impedance of your antenna.--></p>

<p>Tom Berger (K1TRB) used multiple core materials with trifilar wire and performed tests using his N2PK 
 virtual network analyzer on May 19th (2013).</p>
<p class="quote">Hams love type 43 ferrite, but for almost every application, there is a better choice.  For broadband HF transformers Steward 35T is generally a better choice.  Therefore, I wound a couple transformers and did the comparison. <a href="/gnuradio/HF Transformers for rtlsdr balun_ Tom Berger_ 2013.pdf">Type 43 and 35T Transformer Material Compared</a></p> 

<p>For my tests with direct sampling mode I ordered a couple wideband transformers from coilcraft. The <a href="http://www.coilcraft.com/pwb.cfm">PWB-2-ALB and PWB-4-ALB</a> to be specific. I sampled the PWB-4-ALB for free and ordered 4 of the PWB-2-ALB for ~$10 shipped. Both seem to work fine though I have no means of comparative testing.</p>

<p>If you're particularly interested in HF work then an upconverter would be better than the HF mod. With the mod there will be aliases(*) for any frequency over 14.4 Mhz (1/2 the 28.8 clock rate). So you'd want a 14 MHz lowpass for the low end or a 14-28 MHz bandpass for the high end. And probably other little idiosyncracies. A lot of people chose to just use an upconverter instead. KF7LE wrote up short summaries comparing <a href="http://blog.kf7lze.net/2012/09/14/round-up-of-rtlsdr-upconverter-choices/">16 popular upconverters</a>.</a><!--The Nooelec "Ham It Up" is a popular example.--></p>

<p>Another alternative is to make a diplexer so that you get both HF via direct sampling and VHF+/etc without any switches. G8JNJ has a <a href="http://www.g8jnj.net/softwaredefinedradio.htm">detailed guide with annotated photos</a> on how to build the appropriate circuit and modify the latest R820T2 type dongles with it. He reports being able to receive from 15 KHz to 1.8 GHz with this mod.</p>
<!--
<p>As of now it'll only work at 2.048 MS/s sample rate and, as I understand it, only one of the analog to digital converters will be used (I or Q). When using the modified rtlsdr if the library receives a frequency setting under 30Mhz it disables the tuner (high impedance on input) and does direct sampling with the realtek chip. For the default frequency ranges the tuner is left alone and everything works normally (excepting potential interference from the HF antenna). The frequency offset during direct sampling mode will vary with a periodicity due to something resulting from the rtl2832u quadrature output direct digital synthesis frequency generator.

<!-- It *might* be approximately, Frequency offset = N * 264Hz. Also contributing a random amount to the frequency error is the drift in the low quality 28.8 Mhz crystal oscillator.--> 

<!--A recent test performed by <a href="http://mikikg.wordpress.com/">mikikg</a> with a Marconi 2019A signal generator shows bad <a href="http://www.superkuh.com/gnuradio/mikikg_HF_freq_offsets.png">frequency errors below 10Mhz</a> with decent behavior above. 
-->

<!-- But this behavior may have been a result of the HF mod using one a <a href="http://cgit.osmocom.org/cgit/rtl-sdr/tree/src/librtlsdr.c?h=steve-m/direct_sampling#n682"> "magic" sample rate</a> (ie, 2310000/2048000 = 1,1279296875). --> <!-- reddit: <a href="http://www.reddit.com/r/RTLSDR/comments/ujbzl/theres_an_experimental_branch_of_librtlsdr_that/">announcement</a>, <a href="http://www.reddit.com/r/RTLSDR/comments/vq5q3/we_should_get_serious_about_making_the_direct/">further discussion</a>.</p>
-->

<!--
<pre>git clone git://git.osmocom.org/rtl-sdr.git -b steve-m/direct_sampling</pre>
-->

<!--
<h5>Sample rates</h5>
<p>When setting sample rates in your own programs or scripts try to use one of the values shown in, <a href="http://cgit.osmocom.org/cgit/gr-osmosdr/tree/lib/rtl/rtl_source_c.cc#n373">http://cgit.osmocom.org/cgit/gr-osmosdr/tree/lib/rtl/rtl_source_c.cc#n373</a>. If it's an end-user app like SDR# or Gqrx then it handles all this for you in the background. It's handy for writing pyrtlsdr scripts though.</p>
<pre>  range += osmosdr::range_t( 250000 ); // known to work
  range += osmosdr::range_t( 1000000 ); // known to work
  range += osmosdr::range_t( 1024000 ); // known to work
  range += osmosdr::range_t( 1800000 ); // known to work
  range += osmosdr::range_t( 1920000 ); // known to work
  range += osmosdr::range_t( 2000000 ); // known to work
  range += osmosdr::range_t( 2048000 ); // known to work
  range += osmosdr::range_t( 2400000 ); // known to work
//  range += osmosdr::range_t( 2600000 ); // may work
//  range += osmosdr::range_t( 2800000 ); // may work
//  range += osmosdr::range_t( 3000000 ); // may work
//  range += osmosdr::range_t( 3200000 ); // max rate</pre>
-->

<a name="removedtuner">
<h4>Removing the tuner entirely</h4>

<p>Since the tuner is not used in direct sampling it can be removed entirely (especially in a case where it is dead). Goatman contacted me on ##rtlsdr IRC about the process and pin jumpers needed to feed the rtl2832u the clock directly from the onboard oscillator in his case.</p>
<pre>&lt;Goatman&gt; with a simple wire from pin 8 to 10 on the tuner pad
&lt;Goatman&gt; rtl_test reports all is well with direct sampling
&lt;Goatman&gt; ... Gqrx works fine btw with direct sampling even if no tuner is found</pre>
<a href="/goatman-no-tuner-mod.jpg"><img src="http://erewhon.superkuh.com/goatman-no-tuner-mod_sm.jpg"></a>
<br clear="all">

<!--This was actually stupid. Having another metal layer that conformally close creates a capacitance-->
<!--<a href="http://erewhon.superkuh.com/gnuradio/tapeshielding.jpg"><img style="float:left;margin-right:1em;margin-top:1em;" src="http://erewhon.superkuh.com/gnuradio/tapeshielding_sm.jpg" /></a>-->


<a name="noise">
<div>
<h3>Noise, shielding, cables, and why is that FM signal there?!</h3>
<p>When you see something weird, like commercial FM broadcasts at 27 MHz, what you are seeing incomplete filtering of mixing products. It's the harmonics of the square wave driving the mixers combined with insufficient rf filtering to suppress the response. You can tell if it is a local oscillator mixer harmonic leakage by sweeping the frequency and seeing how fast the ghost signal moves relative to this; look for linear relationships (ie, 2x the speed, 1/4 the speed, <a href="http://www.rfcafe.com/references/electrical/image-frequency.htm">in-depth reference</a>). Sometimes local signals can be powerful (ie, pagers) or close enough to make the preamplifier behave non-linearly resulting in intermodulation. For this kind of RFI turning down the gain helps.</p>

<!--
    Carriers at multiples of the 28MHz clock oscillator
    Wideband noise with spurs from the USB data lines
    Wideband noise with spurs from the on board 3.3v to 1.2v DC-DC convertor
-->

<p>The tuners all have a certain amount of intrinsic noise too. keenerd had done tests with an R820T rtlsdr terminated to a resistor inside of a metal box. For these tests rtl_power gain was set to max (49.6dB) and a frequency sweep was done through the entire tuner range, <a href="http://kmkeen.com/tmp/r820t-noise-2.png">r820t Background Noise</a>. The 28.8 MHz spikes from the clock frequency can be seen among other abberations.</p>

<p>But not everything is a ghost from hardware design problems. Depending on your computer setup and local electronics there could be a lot of "real noise"; LCD monitors are a common culprit for VHF noise spikes distributed across wide ranges. It is best to shield and put ferrites on everything if you can.</p>

<p>To solve the commercial FM mixing problems an FM trap can be used. Commercial ones work fine typically. But for non-commercial FM RFI like emergency services and pagers custom filters must be made or ordered. Adam-9A4QV has a <a href="http://lna4all.blogspot.hr/2015/10/diy-fm-trap-or-88-108-mhz-band-stop.html">detailed write-up on making FM trap</a> with a very high upper passband (all the way to 1.7 GHz) with links to design for other low VHF bands. tejeez shared his VHF bandstop design on IRC. Like Adam's it has the unique feature of not also wiping out harmonics of the FM band: <a href="http://prkele.prk.tky.fi/~peltolt2/fm-notch.jpg">fm-notch.jpg</a> <a href="http://prkele.prk.tky.fi/~peltolt2/fm-notch_schematic.png">fm-notch_schematic.png</a>. This means you can use it and still do wideband frequency hopping (unlike, say, a 1/4th wave coaxial stub). For more information on this general type of coaxial cable notch filter check out Ed Loranger's write up on <a href="http://www.qsl.net/we6w/projects/vhf_notch.txt">VHF Notch filters</a> (<a href="/vhf_notch_filter.jpg">photo</a>). For my powerful 461 MHz RFI that can be received without an antenna I use a custom 3 cavity notch filter from Par Electronics.</p>

<p><a href="http://www.acinonyx.tk/index.php/2012/10/28/shielding-eztv668/?lang=en">Acinonyx describes</a> one way to doing this using a single strip of aluminum tape combined with a spring to connect it to the dongle ground. Akos Czermann at the sdrformariners blog made a somewhat confusing but definitely empirical <a href="http://www.sdrformariners.blogspot.co.nz/2013/09/reducing-electrical-noise.html">comparison of noise levels compared to different hardware mods</a> like disconnecting the USB ground from the rtlsdr ground. Quite a few people have had success with that and scotch tape around the USB connector works to test it.</p>

<p>Some others bond the enclosure to both the antenna and the USB shield and this works reliably and well.</p>

<p>Martin from <a href="http://www.g8jnj.net/currentprojects.htm">g8jnj.net</a> finds the most effective mod to reduce USB and DC-converter noise is shielding the antenna input area with metal soldered to the pcb ground, "The noise seems to be coupled directly between components on the topside of the PCB." You can find it if you scroll about halfway down the page linked.</p>

<!--<p>I wrap the entire pcb, except the grounds on the connectors, with kapton tape and then use a single continuous piece of aluminum foil tape to wrap the rest of the dongle. This tape touches the dongle ground which is also USB ground. Even sealed with aluminum tape they seem to dissipate heat and reach thermal equilibrium fine in terms PPM error.</p>-->


<img style="float:right;margin-left:1em;" src="http://erewhon.superkuh.com/rtl2832u-switching-regulator.png" />

<p>Additional noise comes from the switching power supply in the RTL2832U that runs at 1.024MHz. This drops the supplied 3.3v down to the 1.2v needed for internal use. <a href="http://blog.livedoor.jp/bh5ea20tb/archives/4908385.html">ttrftech has successfully disconnected this switching supply</a> replaced it with 3 diodes to drop the 5v line down to ~1.2v. In the example linked above ttrftech uses power form the far side of the board but the eeprom's power rail would also work. This decreases spurs in HF significantly. It will increase power usage though; something to watch out for when R820T dongles start out at ~300mA a piece.</p>

<p>Laidukas's "<a href="http://www.laidukas.lt/blog/?p=1022">Mods and performance of R820T2 based RTL SDR receiver</a> covers replacing all the power rails with external linear regulators, increasing the amount of bypass capacitance on power lines, adding extra chip filtering for the USB 5v line, cutting off the IR receiver part of the PCB, wiring in a TCXO 28.8MHz oscillator, creating a shield with kapton tape and copper foil soldered extensively to the PCB ground, and a new heavy metal case and connectors.</p>

<p>To reduce signal loss over long distances and get away from computer RFI I like to run long USB <a href="http://www.monoprice.com/products/subdepartment.asp?c_id=102&cp_id=10303&cs_id=1030312">*active* extension cable</a> with hubs at the end and ferrites added instead of coaxial cable. Around this USB cable I clip on 5 or 6 ferrites at each end. Active extension/repeater USB2 cables of up to <a href="http://www.monoprice.com/Product?c_id=103&cp_id=10303&cs_id=1030312&p_id=7644&seq=1&format=2">25m in length</a> can be used.</p>

</div>


<a name="clocks">
<h3>Using External Clocks and coherent sampling in general...</h3>

<h5>Multiple coherent dongles</h5>

<p>The most exciting development in rtlsdr that has happened recently are Juha Vierinen's <a href="http://gnuradio.4.n7.nabble.com/dual-coherent-channel-rtl-sdr-td43784.html">discuss-gnuradio</a> mailing list and blog posts about a simple and inexpensive method to distribute the clock signal from one dongle to multiple others for coherent operation.</p>
<p class="quote">"I recently came up with a trivial hack to build a receiver with multiple coherent channels using the RTL dongles. I do this basically by unsoldering the quartz clock on the slave units and cable the clock from the master RTL dongle to the input of the buffer amplifier (Xtal_in) in the slave units (I've attached some pictures)."</p>

<p>Since I've seen a lot of people asking, the dongles he used were Newsky TV28T v2 w/R820T tuners.</p>

<ul>
<li><a href="http://kaira.sgo.fi/2013/09/16-dual-channel-coherent-digital.html">$16 dual-channel coherent digital receiver </a></li>
<li><a href="http://kaira.sgo.fi/2013/09/passive-radar-with-16-dual-coherent.html">Passive radar with $16 dual coherent channel rtlsdr dongle receiver </a></li>
</ul>
<a name="anotherpassiveradar">
<p>Max Manning also <a href="https://dopplerfish.com/passive-radar/">implemented a passive radar system using clock sharing rtlsdr</a>. Ben Silverwood also did so as, "<a href="https://www.youtube.com/watch?feature=player_embedded&v=l9V73d0nF4A">
Low cost RTL-SDR passive multistatic DAB radar.</a>" an implementation in matlab. The youtube video description has links to <a href="https://www.youtube.com/redirect?q=http%3A%2F%2Fimgur.com%2Fa%2FijFBg&redir_token=7qWE4Yk5L9y1bydtjGFDdh8jPZh8MTQwMTMzODc2MkAxNDAxMjUyMzYy">photos of the setup</a>.</p>

<p>Also, there's a Japanese seller with high precision SMD 28.8 MHz crystals. And an ebay seller with high precision 28.8 MHz oscillators for around ~$30 shipped.</p>

<p>Things again became exciting in June of 2014. Going beyond simple clock sharing and it's max of 3 dongles, YO3IIU put up a great post his build of a 4+ dongle <a href="http://yo3iiu.ro/blog/?p=1450">RTL2832u based coherent multichannel receiver</a> using a CDCLVC1310-EVM dev board from TI for clock distribution. His post shows the results of a gnuradio block he coded that does all the correlation math to align the samples from each receiver (which are out of step due to the way USB works). Unfortunately the software was never released.</p>

<p>steve|m's experiments were the first I heard about back in 2011. He used his 13MHz cell-phone clock as a reference for a PLL to generate 28.8MHz. He said he used 1v peak to peak. He also related <a href="https://steve-m.de/projects/rtl-sdr/clock/gsmsync_stick.jpg">it was possible</a> to not even use the PLL and just the 13 MHz clock if w/E4000 tuners if you don't care about sample rate offset.</p>
<pre>&lt;steve|m&gt; not really, just a picture and a short clip: <a href="http://steve-m.de/projects/rtl-sdr/osmocom_clocksource.webm">http://steve-m.de/projects/rtl-sdr/osmocom_clocksource.webm</a> <a href="http://steve-m.de/pictures/rtlsdr_external_clock.jpg">http://steve-m.de/pictures/rtlsdr_external_clock.jpg</a>
&lt;steve|m&gt; a motorola C139</pre>

<p>The Green Bay Public Packet Radio guys have written up an interesting article on using 14.4 MHz temperature controlled crystal oscillators sent through a passive (two diode) frequency doubler followed by crystal filters made out of the old rtlsdr clock crystals to provide a low PPM error clock for rtlsdr devices. Since their mirror was missing images I cut them out of the Zine pdf and made a mirror <a href="http://superkuh.com/288/">here</a>.</p>

<p>I first heard about the GBPPR article from patchvonbraun who implemented one and performed tests which he posted about on the Society for Amateur Radio Astronomy list. It turns out that even with a good distributed clock the 2x R820t rtlsdr dongles still have large phase error for some reason, see: <a href="https://groups.google.com/forum/#!topic/sara-list/02KyDILklRg">Phase-coherence experiments with RTLSDR dongles</a> and the photo post: <a href="https://groups.google.com/d/topic/sara-list/gg4WjwDB7Pw/discussion">Progress towards using RTLSDR dongles for interferometry</a>.</p>

<p><a href="http://www.radio-sky.ru/forums/index.php?s=446f2786c874ccc452ce74239c0e472a&showtopic=65&st=0&p=324&#entry324">Alex Paha has also done clock distribution</a> but unlike the others he used E4000 tuner based receivers for his <a href="http://www.radio-sky.ru/forums/index.php?act=attach&type=post&id=228">dual coherent receiver</a>. He also seems to be using only half the I/Q pairs. This post is in Russian.</p>


<!--
<p>tejeez is testing out the idea of using external pulses to measure and correct phase difference. You can see the setup in <a href="http://prkele.prk.tky.fi/~peltolt2/DSC_1246.jpg">this preliminary</a> and <a href="http://prkele.prk.tky.fi/~peltolt2/DSC_1277.jpg">this final</a> photo. The chips are sa630 switches which will disconnect antennas for a short time and connect all dongles to the same source. It looks for i2c clock pulses and has two RC delay circuits so that every time you change frequency (causing i2c traffic) it disconnects antennas, waits for some time, feeds a pulse (just one edge from the logic chip) into both dongles, waits a bit more and connects the antennas back. This should allow measuring the absolute phase shift and time difference between dongles. -->

<!-- In addition to providing alignment pulse/signal this kind of setup could be used as a <a href="http://www.setileague.org/askdr/dicke.htm">Dicke-switch</a> to control for changes in dongle gain drift.--></p>


<a name="clocks.align">
<h5>Actually maintaining coherence over re-tunes and USB2 latency</h5>

<h6>rtl_coherent</h6>
<p>In October 2015 teejez uploaded his <a href="https://github.com/tejeez/rtl_coherent">rtl_coherent</a> code for maintaining multi-dongle coherence using external antenna switches to disconnect the antennas and connect all to a common noise source for correlation calibration. Here's a video of him using it to make a <a href="https://www.youtube.com/watch?v=8Wzb1mgZ0EE">3 dongle direction finder</a>.</p>

<p class="quote">Each dither-disabled rtl-sdr is fed from the same reference clock. They still have unknown phase shifts and sampling time differences relative to each other. This is calibrated by disconnecting them from antennas and connecting every receiver to the same noise source. Cross correlation of the noise gives their time and phase differences so that it can be corrected. Currently the signal is received and processed in short blocks with each block starting with a burst of calibration noise.</p>

<p>As I understand it the switch chips are sa630 that "look" for dongle i2c traffic. There are controlled by two RC delay circuits so that every time you change frequency (causing i2c traffic) it disconnects antennas, waits for some time, feeds a pulse (just one edge from the logic chip) into all dongles, waits a bit more and connects the antennas back. You can see the evolution of his setup from this earlier <a href="http://prkele.prk.tky.fi/~peltolt2/DSC_1246.jpg">prototype</a> to this <a href="http://prkele.prk.tky.fi/~peltolt2/DSC_1277.jpg">later prototype</a> and finally the <a href="http://prkele.prk.tky.fi/~peltolt2/DSC_2715.jpg">version used</a> in his direction finder.</p>

<p>Every time you tune any two (or more) dongles to a new frequency there <em>will</em> be a tiny difference in the frequency each actually tuned to. The offset must corrected before trying to correlate them. If you don't it'll look like there's a constantly varying phase shift. Also don't forget to let the dongles warm up to equilibrium otherwise this additional temperature related frequency shift will cause changes even larger than relative tuning offset and you'll get the "random" phase shift again.</p>

<h6>Multi-RTL</h6>
<a name="clocks.align.multirtl">
<p>As of 2016 Piotr Krysik's "<a href="https://ptrkrysik.github.io/">Multi-RTL</a>" (<a href="https://github.com/ptrkrysik/multi-rtl">github</a>) has made maintaining coherence of multiple dongles accessible even to the amateur. His GNU Radio block handles all the complex details of keeping multiple rtlsdr coherent even when they're tuned to different frequencies and over re-tunes. It requires no external circuitry. You just have to distribute the clock signal with cable.</p>

<a name="clocks.dithering">
<h5>PLL Dithering and you.</h5>

<p>On the clock coherencey side Michele Bavaro's has explored, tweaked, and replaced, librtlsdr's pll setting code, intermediate frequency, and PLL dithering settings, such that the math, and results, work out cleaner. Using this modified driver he was able to minimize frequency setting errors and improve his GPS carrier following code. This is written up with code examples at his blog in, <a href="http://michelebavaro.blogspot.fi/2014/05/gnss-carrier-phase-rtlsdr-and.html"> GNSS carrier phase, RTLSDR, and fractional PLLs (the necessary evil)</a>. Without dithering you can only tune to increments of 439.45 Hz. With dithering, you can tune to aproximately anything.</p>

<p>tejeez from the ##rtlsdr IRC relates that this can be done in r82xx_set_pll by changing r82xx_write_reg_mask(priv, 0x12, val, 0x08) to r82xx_write_reg_mask(priv, 0x12, val|0x10, 0x18). This has been implemented as an option in rtl_sdr, '-N', in keenerd's experimental branch.</p>

<h5>Misc</h5>

<p>In the absence of any useful information about the RTL2832U clock here's some information about the R820T's clock system.</p>
<p class="quote">Crystal parallel capacitors are recommended when a default crystal frequency of 16 MHz is implemented. Please
contact Rafael Micro application engineering for crystal parallel capacitors using other crystal frequencies. For cost
sensitive project, the R820T can share crystal with backend demodulators or baseband ICs to reduce component
count. The recommended reference design for crystal loading capacitors and share crystal <a href="http://erewhon.superkuh.com/gnuradio/r820t_clock.png" />is shown as below</a>.</p>

<img src="http://erewhon.superkuh.com/gnuradio/r820t_clock.png" />

<div>

<a name="broadbandantenna">

<h4>Antenna, but particularly broadband antenna</h4>


<!--<a href="/discone_dish.jpg"><img src="http://erewhon.superkuh.com/antennas.jpg" /></a><br />-->

<a href="http://erewhon.superkuh.com/discone-antenna.jpg"><img src="http://erewhon.superkuh.com/discone-antenna_sm.jpg"></a><a href="http://erewhon.superkuh.com/spiral-antenna.jpg"><img src="http://erewhon.superkuh.com/spiral-antenna_sm.jpg"></a><a href="http://erewhon.superkuh.com/planar-disk-antenna.jpg"><img src="http://erewhon.superkuh.com/planar-disk-antenna_sm.jpg"></a><a href="http://erewhon.superkuh.com/Split-Ring-Resonator_Notch-Filter_Vivaldi-Antenna.jpg"><img src="http://erewhon.superkuh.com/Split-Ring-Resonator_Notch-Filter_Vivaldi-Antenna_sm.jpg"></a><a href="http://erewhon.superkuh.com/milk-bucket-1626MHz-helicone.jpg"><img src="http://erewhon.superkuh.com/antennas-helicone.jpg" /></a><a href="http://erewhon.superkuh.com/weatherized-horn.jpg"><img src="http://erewhon.superkuh.com/weatherized-horn_sm.jpg"></a><a href="/k-antenna-horn.jpg"><img src="http://erewhon.superkuh.com/k-antenna-horn_sm.jpg" /></a><!--<a href="http://erewhon.superkuh.com/archery-target-antenna.jpg"><img src="http://erewhon.superkuh.com/archery-target-antenna_sm.jpg"></a>-->

<p style="font-style: italic;">I've also written up a seperate, longer, page on the <a href="/thisurlnamehasnothingtodowiththeactualtopicijustnameditthisforkicks.html">challenges and solutions when implementing broadband antenna</a>.</p>

<p>When I want to do some scanning that takes advantage of the tuner's very wide ranges I use five types of antenna: discone, spiral, dual planar disks, vivaldi (tapered slot), and horns (TEM and pyramidal). Discone, <a href="http://erewhon.superkuh.com/planar-disk-antenna.jpg">dual planar disk</a>, and archimedian spiral antenna can omnidirectionally cover almost the full range of the E4000 tuner but things get a bit too large to go all the way to the 24 Mhz of the R820T. You can refer to the seperate <a href="/spiralantenna.html">spiral antenna</a> page for construction and technical details. To build <a href="http://superkuh.com/discone_dish.jpg">my discone</a> I followed Roklobsta's <a href="http://helix.air.net.au/index.php/d-i-y-discone-for-rtlsdr/">D.I.Y. Discone for RTLSDR</a> (<a href="http://web.archive.org/web/20150622125505/http://helix.air.net.au:80/pics/Discone/">archive.org mirror</a>). With just a discone and rtl_power it's possible to see lots of LEO satellite carrier frequencies doppler across the spectrum.</p>

<img style="float:left;margin-right:1em;" src="http://erewhon.superkuh.com/437MHz_satellite.png" />

<p>To get an idea of how much you can see with a discone here's a <a href="/radio/">directory</a> where I produce ~2 to 4 day long ~70 to 1000 MHz range 25KHz resolution 45k*10k pixel spectrograms. They each have a javascript zoomable interface to load small tiles progressively. An <a href="http://superkuh.com/radio/2014-08-26_17-55_70-1000_25k/">example</a>. With just a discone and rtl_power it's possible to see lots of LEO satellite carrier frequencies doppler across the spectrum.</p>

<p>But with a band specific helix in a cone reflector (helicone) <a href="http://ironpants.superkuh.com/radio/2015-01-05_10-33_1615-1627_1k_E4000/">many more satellites can be picked up</a>. The previous is a link to a zoomable spectrogram of ~2 days of the 1616-1626 MHz satellite band that Iridium satellites use. No LNA was used. There's plenty of RFI/EMI even through a 1 GHz high pass but the satellite doppler passes are clearly there in numbers if you zoom in far enough. </p>

<p>When using such broadband antenna, or even a band specific helix, it is possible to pick up powerful out of band signals due to overloading or incomplete mixer filtering. It's important to identify any extraordinarily powerful transmitters nearbye and filter them out. In my case I have a 50w transmitter at 461 MHz across the street <em>always</em> going full power. I bought a custom tuned 3 cavity notch filter from PAR Electronics. This limits the upper frequency range to 1GHz but does at least solve the RFI problem.</p><!-- You can see an example of how bad this interference can be in raw sample total power measurements over time x frequency in these 2D spectral maps:  <a href="/gnuradio/nasty.png">1</a>, <a href="/gnuradio/live/spectral-map.png">2</a>. Or in the 1D spectrum plot below,</p>
-->

<!--
<a href="http://erewhon.superkuh.com/gnuradio/54-1100_discone.png"><img src="http://erewhon.superkuh.com/gnuradio/54-1100_discone_sm.png" /></a>
-->
<!--<a href="http://erewhon.superkuh.com/gnuradio/1350-2200_discone.png"><img src="http://erewhon.superkuh.com/gnuradio/1350-2200_discone_sm.png" /></a>-->
<!--
<p>The powerful signals near 155 and 930 Mhz and particularly the university's multiple 45 watt ~461 Mhz transmitters across the street appear as images (?) all over into other frequency bands. Nasty. In the future I hope to notch them out with physical filters. The linked plot above is made with <a href="/gnuradio/gnuplotexample.txt">this gnuplot format</a> and the csv output of <a href="https://github.com/EarToEarOak/RTLSDR-Scanner">RTLSDR Scanner</a> using 1 second integration times with a wire discone. In 2013 I did fix this with a custom made PAR Electronics 3 cavity notch filter for 461 MHz. I can even pick up 437 MHz LEO satellites with my discone now,</p>-->



<!--<img src="/gnuradio/dongleoverload.png" />-->

<p>Usually the spectra are much cleaner when using directional and resonant antenna instead of wideband omnidirectionals. But many directional antenna like helix and log periodic dipoles have very large out of band sidebands on low frequencies not in the designed range.</p>




<!--<p>patchvonbraun suggested doing a frequency sweep with a shielded terminated resistor and then subtracting that sweeps' results from the antenna scans. <a href="https://github.com/EarToEarOak/RTLSDR-Scanner">RTLSDR Scanner</a>'s sweeps for the same range and sample rate always match up on frequencies. So it should be just subtracting the corresponding elements of the sorted value pairs from antenna and resistor using self.spectrum.iteritems() in RTLSDR Scanner or using unix tools with the csv. This might not be reasonable thing to do though because the values are in dB and subtraction does not work simply with dB.</p>-->



<!--<img src="/" />-->


</div>
<!--
<pre># Frequency (MHz),Level (dB)		# Frequency (MHz),Level (dB)
54.00196,-45.6883596633			54.00196,-62.1023728582
54.0039,-45.7144431488			54.0039,-62.7271718357</pre>
</p>
-->

<hr />

<a name="links">

<div style="float:right;"><h3>Chipset docs, GNU Radio, DSP, and Antenna Links</h3>
<ul>


<!--<li><a href="/gnuradio/120903_RTL2832_2836_2840_LINUX+rc+dab+fm.rar">RTL2832U Linux Driver Source</a> (not SDR mode)</li>-->
<li><a href="/gnuradio/RTL2832U-Digital_Down_Conversion_SDR_Zemj.ulck.pdf">RTL2832U Downconversion Notes</a> (pdf)</li>
<li><a href="/gnuradio/RTL2832U-SDR-Setting-Semj.ulck.pdf">RTL2832U Register Notes</a> (pdf)</li>
<li><a href="/gnuradio/R820T_datasheet-Non_R-20111130_unlocked.pdf">Rafael Micro R820T tuner datasheet</a> (pdf)</li>
<li><a href="/R820T2_Register_Description.pdf">R820T2 Register Descriptions</a> (pdf)</li>
<li><a href="http://www.superkuh.com/gnuradio/Elonics-E4000-Low-Power-CMOS-Multi-Band-Tunner-Datasheet.pdf">Elonics E4000 Low Power CMOS Multi-Band Tuner Datasheet</a> (pdf)</li>
<li><a href="/gnuradio/e4000_refsch_rev4.pdf">Elonics E4000 reference schematic</a> (pdf)</li>
<li><a href="http://www.elonics.com/uploads/assets/E4000_WP_English_Benefits_of_DigitalTune_Architecture_March_2008.pdf">E4000 Benefits of DigitalTune Architecture</a> (pdf)</li>
<li><a href="http://gnuradio.org/redmine/projects/gnuradio/wiki">GNU Radio Wiki</a></li>
<!--<li><a href="http://gnuradio.org/redmine/projects/gnuradio/wiki/UbuntuInstall">Building GNU Radio on Ubuntu Linux</a> - GNU Radio Wiki</li>-->
<li><a href="http://lists.gnu.org/pipermail/discuss-gnuradio/">http://lists.gnu.org/pipermail/discuss-gnuradio/</a></li> 
<li>gnuradio's <a href="https://www.cgran.org/browser/projects">https://www.cgran.org/browser/projects</a></li>
<li><a href="http://www.oz9aec.net/index.php">oz9aec</a>'s <a href="http://www.oz9aec.net/index.php/gnu-radio/grc-examples">GRC Examples</a></li>
<li><a href="https://github.com/csete/gnuradio-grc-examples/tree/master/receiver">https://github.com/csete/gnuradio-grc-examples/tree/master/receiver</a></li>
<!--<li><a href="http://swigerco.com/gnuradio/modules.html">gnuradio module usage</a> - the bit on <a href="http://swigerco.com/gnuradio/fir_filter.html">FIR Filters</a></li>-->
<!--li><a href="https://github.com/csete/gqrx">https://github.com/csete/gqrx</a> - "gqrx is an experimental AM, FM and SSB software defined receiver implemented using GNU Radio and the Qt GUI toolkit." people from freenode ##rtlsdr have added <a href="#gqrx">OsmoSDR support to gqrx</a>.</li> 
<li><a href="http://2h2o.tumblr.com/">2h20's example</a> - a very simple mono FM example that is easy to learn from.</li>-->
<!--<li><a href="https://github.com/loxodes/rtl-sdr-lna">low noise amplifier for rtl2832</a></li>-->
<!--<li><a href="https://github.com/ambrosa/DVB-Realtek-RTL2832U-2.2.2-10tuner-mod_kernel-3.0.0">actual television decoding driver for linux</a>, <a href="http://www.linuxtv.org/wiki/index.php/RealTek_RTL2832U">2</a></li>-->
<li><a href="http://superkuh.com/blazevideo6.0dab-r820t.zip">R820T DAB+ driver</a> (<a href="https://github.com/steve-m/rtltcpaccess/">related</a>)</li>
<li><a href="http://spench.net/">balint256</a>'s <a href="http://www.youtube.com/user/balint256/videos">GNU Radio tutorial videos</a></li>
<li><a href="http://www.reddit.com/r/GNURadio/comments/s0rpg/good_books_to_get_started_with_gnu_radio/c4a61jw">firebyte's post on r/GNURadio</a>
	<ul>
<li><a href="http://radioware.nd.edu/documentation">Radioware Documentation</a> - GNU Radio tutorials</li>
<li><a href="http://gnuradio.org/redmine/projects/gnuradio/wiki/SuggestedReading">GNU Radio suggested reading</a></li>
<li><a href="http://www.csun.edu/~skatz/katzpage/sdr_project/sdrproject.html">CSUN/EAFB Software Defined Radio (SDR) Senior Project</a></li>
<li><a href="http://www.dspguide.com/">The Scientist and Engineer's Guide to Digital Signal Processing</a></li>
<li><a href="http://www.eecs.berkeley.edu/~dtse/book.html">Fundamentals of Wireless Communication</a></li>
<li><a href="http://www.complextoreal.com/tutorial.htm">Tutorials in Communications Engineering</a></li>
	</ul>
</li>
<li><a href="http://people.scs.carleton.ca/~barbeau/SDRBook/">Software Radio for Experimenters with GNU Radio, Octave and Python</a></li>

<li><a href="http://www.antenna-theory.com/antennas/main.php">Antenna Theory</a></li>
<li><a href="http://www.youtube.com/watch?v=DovunOxlY1k">AT&T Archives: Similiarities of Wave Behavior</a> - impedance explained</li>
</ul>
</div>

<h3>Page Sections</h3>
<ul>
<li><a href="#intro">Intro</a></li>
<li><a href="#hardware">Hardware</a></li>
<li><a href="#interferometer">My Interferometer</a></li>
<li>Links/Datasheets (here)</li>
<li><a href="#installing">Installing RTLSDR and GNU Radio</a></li>
<li><a href="#appnotes">RTLSDR Applications Notes</a></li>
<li><a href="#pager">Pagers</a></li>
<li><a href="#gqrx">Gqrx on Ubuntu 10.04</a></li>
<li><a href="#ltescanner">LTE Scanner on Ubuntu 10.04</a></li>
<li><a href="#pyrtlsdr_logger">Dongle Logger</a></li>
<li><a href="#grc">GNU Radio Companion</a></li>
<li><a href="#clocks">Clocks</a></li>
<li><a href="#broadbandantenna">Broadband Antenna</a></li>
</ul>

<h3>RTL-SDR Links</h3>
<ul>
<li><a href="http://sdr.osmocom.org/trac/wiki/rtl-sdr">rtl-sdr wiki</a> - osmocom</li>
<li><a href="http://sdr.osmocom.org/trac/wiki/rtl-sdr#KnownApps">Known applications - rtl-sdr wiki</a> - osmocom</li>
<li><a href="http://www.rtlsdr.org/">rtlsdr.org wiki</a></a>
<li><a href="http://www.reddit.com/r/rtlsdr">r/rtlsdr</a> - reddit group</li>
<li><a href="https://groups.google.com/forum/#!forum/ultra-cheap-sdr">Ultra Cheap SDR</a> - google group</li>
<li><a href="http://groups.yahoo.com/group/rtlsdr/">RTL-SDR</a> - yahoo group</li>
<li>AB9IL's <a href="http://www.ab9il.net/software-defined-radio/rtl2832-sdr.html">rtl2832 software defined radio overview</a></li>
</ul>



<br clear="all" />

<hr />

<h4>Warning: I'm learning as I go along. There are errors. Refer to the proper documentation and original sources first.</h4>

<hr />


<a name="installing">

<h3>GNU Radio *and* RTL-SDR Setup</h3>
<p>You don't need GNU Radio to use the rtlsdr dongles in sdr mode, but there <em>are</em> many useful apps that depend on it. <a href="http://www.sbrac.org/">patchvonbraun</a> has made setting up and compiling GNU Radio and RTLSDR with all the right options very simple on Ubuntu and Fedora. It automates grabbing the latest of everything from git and compiling. It will also uninstall any packages providing GNU Radio already installed first. Simply run, <a href="http://www.sbrac.org/files/build-gnuradio">http://www.sbrac.org/files/build-gnuradio</a>, and it'll automate downloading and compiling of prequisites, libraries, correct git branches, udev settings, and more. I had no problems using Ubuntu 10.04, 12.04, or 14.04. These days (2015) pybombs is slowly taking over for build-gnuradio but for now this works best.</p>

<p>If you're thinking about trying this in a virtual machine: don't. If you do get it partially working it'll still suck.</p>

<p>As an aside: If you're an OSX user then you can use the <a href="https://gnuradio.org/redmine/projects/gnuradio/wiki/MacInstall#Via-MacPorts-recommended">MacPorts version of GNU Radio</a> (including gqrx, etc) maintained by Michael Dickens. <!--Alternately refer to the slightly older <a href="http://dekar.wc3edit.net/2012/09/30/osx-port-of-the-awesome-gqrx-sdr-software/">dekars work for gqrx</a> that contains rtl-sdr, gr-osmosdr, GNU Radio, libUSB, boost and Qt dependencies.--></p>
<pre>mkdir gnuradio
cd gnuradio
wget http://www.sbrac.org/files/build-gnuradio
chmod a+x build-gnuradio
./build-gnuradio --verbose          # default is latest 3.7
*or*
./build-gnuradio -o --verbose       # install old 3.6.5.1</pre>

<p>Install 3.7. Most gnu radio projects have been ported to it as default. Only a few old things will require 3.6.</p>

<p>An (<a href="build-gnuradio.txt">re</a>)install looks like <a href="build-gnuradio2.txt">this</a>. It might be useful to save the log output for future reference. Then test it. The test output below is from a very old version of rtl_test with an E4K dongle. Newer versions, and R820T tuners will output slightly different text.</p>
<pre>rtl_test -t
Found 1 device(s):
  0:  ezcap USB 2.0 DVB-T/DAB/FM dongle

Using device 0: ezcap USB 2.0 DVB-T/DAB/FM dongle
Found Elonics E4000 tuner
Benchmarking E4000 PLL...
[E4K] PLL not locked!
[E4K] PLL not locked!
[E4K] PLL not locked!
[E4K] PLL not locked!
E4K range: 52 to 2210 MHz
E4K L-band gap: 1106 to 1247 MHz</pre>

<p>Once GNU Radio is installed the <a href="http://sdr.osmocom.org/trac/wiki/rtl-sdr#KnownApps">"Known Apps"</a> list at the  rtl-sdr wiki is a good place to start. Try running a third party receiver, a python file or start up GNU Radio Companion (gnuradio-companion) and load the GRC flowcharts. If you're having "Failed to open rtlsdr device #0" errors make sure something like /etc/udev/rules.d/<a href="https://raw.github.com/keenerd/rtl-sdr/master/rtl-sdr.rules">15-rtl-sdr.rules</a> exists and you've rebooted.</p>

<h5>Updating</h5>
<p>When updating you can just repeat the install instructions which is simple but long. The advantage to repeating the full process is mainly if there are major changes in the gr-osmosdr as well as rtl-sdr. It'll do things like ldconfig for you.</p>
<pre>./build-gnuradio -e gnuradio_build</pre>
<h5>Just compile/installing rtl-sdr</h5>
<p>If you don't have the patience for a full recompile and there haven't been major gnu radio or gr-osmosdr changes it's much faster just to recompile rtl-sdr by itself. The instructions to do so are at the <a href="http://sdr.osmocom.org/trac/wiki/rtl-sdr">osmosdr page</a>. It'll only take a few minutes even on slow machines. Once you have the latest git clone it is like most cmake projects:</p>
<pre>git clone git://git.osmocom.org/rtl-sdr.git
cd rtl-sdr; mkdir build; cd build; cmake ../ ; make; sudo make install; sudo ldconfig</pre> 
<!--<p>Alternately you can do it piecemeal for just gr-osmosdr. It needs to see the rtl-sdr libs in order to include rtl-sdr support in it.  gr-osmosdr is a "generic" source block for Gnu Radio, which include FCD, RTL-SDR, UHD, osmosdr. So, make/install rtl-sdr, then in gr-osmosdr:</p> -->
<!-- or "git pull" in the gnuradio dir, then cd build; make; sudo make install, same for the rtl-sdr and gr-osmosdr stuff.) -->
<!-- <pre>make clean;  cmake . ; make; sudo make install; sudo ldconfig</pre>-->
<!--<p>The GRC flowcharts sometimes require changes in the source blocks and parameters after updating. Or just update from whatever repository it came from.</p>-->

<!--<p>For replacement OsmoSDR source blocks the addition of "rtl=0" in "Device Arguments" and the explicit setting of "Chan 0: Frequency". Manual gain control (instead of automatic) seems to have much more of an effect than before.</p>-->

<hr />

<a name="appnotes">

<h3>rtl-sdr supporting receivers, associated tools</h3>
<ul>

<a name="keenerdappnote">
<li><a href="https://github.com/keenerd/rtl-sdr">keenerd's rtl-sdr branch</a><ul>
	<li>This experimental branch contains a number of useful low processing power utilities, expansions of the original rtl tools, and improvements to the R820T driver re-tuning speed. A lot of them have already been merged into the librtlsdr master but rtl_fm and rtl_power fixes, features and bugs appear here first. rtl_fm is for scanning, listening, and decoding (and not just FM), rtl_adbs for plane watching with an external ads-b viewer, rtl_eeprom for checking and *setting* serial numbers and related data if your dongle has an eeprom. And as of 2013-09-20, rtl_power, a total power frequency scanner.<!-- He also added using ntp servers to estimate frequency offsets of dongles into rtl_test.  --> These tools are very good for slow machines or when you want to do command line automation. Just build it like the <a href="http://sdr.osmocom.org/trac/wiki/rtl-sdr#Buildingthesoftware">osmocom rtlsdr page does</a> for the vanilla install. Use these on the raspberry pi.<!-- Use it with <a href="https://github.com/TonberryKing/fm-multimix">fm-multimix</a> to decode multiple narrowband FM channels at once.--></li>

<!--<p>Normally you'd get a copy like,</p>-->
<pre>git clone https://github.com/keenerd/rtl-sdr.git
git clone https://github.com/keenerd/rtl-sdr-misc</pre>


 <!--<p>But if you want the fast re-tuning branch (twice the main branch R820T speed) then you have to specify it like,</p>

<pre>git clone -b fast-r820t https://github.com/keenerd/rtl-sdr.git</pre>-->

<!--<pre>cd rtl-sdr; mkdir build; cd build; cmake ../; make; cd src;</pre>-->
<pre>cd rtl-sdr; mkdir build; cd build; cmake ../ -DINSTALL_UDEV_RULES=ON; make; sudo make install-udev-rules; sudo ldconfig</pre>

<p>Most people use rtl_power for smaller total bandwidths (&lt;200 MHz) and higher spectral resolution using the default FFT mode. This is visualized with keenerd's <a href="http://kmkeen.com/tmp/heatmap.py.txt">heatmap.py</a> and can result in some <a href="http://erewhon.superkuh.com/tholin_rtlsdr.png">really impressive plots</a> when done with ~25% crop mode. Just refer to the -h "<a href="https://github.com/keenerd/rtl-sdr/blob/master/src/rtl_power.c#L117">help</a>" in rtl_power for instruction. There is also an <a href="http://kmkeen.com/rtl-power/">rtl_power guide</a> at keenerd's website.</p>

<p>For RMS average power mode, which kicks in automatically for FFT bin sizes 1 MHz and larger, I do visualization of the resulting .csv file with gnuplot. Because the entire bandwidth is summed and saved as one value the the data rate to disk, and spectrogram dimensions are much lower than FFT mode.</p>

<p>Example <a href="http://erewhon.superkuh.com/r820t9.png">gnuplot visualization</a>, <a href="http://erewhon.superkuh.com/signalguesses.png">annotated</a>, and the <a href="/gnuplot-format-rms-mode.txt">gnuplot format</a>, and <a href="/default.plt.txt">colour palettes</a> used to generate them.</p>

<p>If you do a large number of frequency hops, (hundreds) then the time adds up. On my two computers the R820T tuner dongles average about 55 milliseconds per retune and sample cycle. I sometimes have dongles that'll fail to lock pll and go into a loop. The -e parameter sets a time limit for a run. Combining this time limit with a bash while loop results in pretty low downtime with resiliance to rtlsdr and USB failures.</p>

<pre># 0.055 seconds *((1724-24) MHz/(1 MHz)) = 93.5 seconds = "-i".
while true; do ./rtl_power -f 24M:1724M:1M -i 94 -g 20.7 -p 30 -e 1h >> 2013-12-02_totalpower_r820t_24-1724_1M_94s.csv; done</pre>

<p>To combine the results from multiple dongles just cat the files together. But on gnuplots end each new .csv filename requires you to manually edit the gnuplot format. Additionally you need to set the output spectrogram filename and a pixel width. I find for 1000 Mhz @ 1 MHz that approximately 1000px per 100 MB of file size is required to cover all gaps.</p>

<pre>gnuplot gnuplot-format-rms-mode.txt</pre>

<p>And that pops out a <a href="http://erewhon.superkuh.com/r820t9.png">png</a>.</p>

<p>For rtl_fm stuff refer to keenerd's site's <a href="http://kmkeen.com/rtl-demod-guide/">Rtl_fm Guide</a>.</p>
<!--
<pre># an example usage of rtl_fm to play commercial FM radio
rtl_fm -W -f 89.3M | play -t raw -r 32k -e signed-integer -b 16 -c 1 -V1 -
# scanner for the AM airband
rtl_fm -M -f 118M:137M:25k -s 12k -l 280 | play -t raw -r 12k -e signed-integer -b 16 -c 1 -V1 -
# local narrow FM emergency channels
rtl_fm -N -E -f 154.98000M -f 155.06250M -f 155.28000M -f 155.34000M -s 12k -o 4 -l 550 | play -t raw -r 12k -e signed-integer -b 16 -c 1 -V1 -
# send plane AVR data to a <a href="http://89.158.68.10:8080/VirtualRadar/GoogleMap.htm">remote server</a>
rtl_adsb | socat -u - TCP4:sdrsharp.com:47806
# combine multimonNG with rtl_fm to live decode POCSAG
rtl_fm -f 153.353e6 -g 100 -s 22050 -l 310  |multimon -t raw -a POCSAG1200 -f alpha /dev/stdin
</pre>
-->
<!-- # or, to handle crashes...
while true; do rtl_adsb | socat -u - TCP4:sdrsharp.com:47806 &amp;&amp; <a href="http://www.roman10.net/how-to-reset-usb-device-in-linux/">usbreset</a>; done; 
-->
    </ul>
</li>


<a name="spektrumappnote">
<li><a href="https://github.com/pavels/rtl-sdr">Spektrum: an rtl_power GUI frontend</a>:
	<ul><li>There are a lot of rtl_power GUI frontends but the most useful for me is Spektrum. It uses a modified rtl_power with a Processing GUI front-end. It's available for linux and windows. One of it's best features is the "relative mode" for use in measuring changes in antennas and filters.</li></ul>
</li><br />


<a name="multimodeappnote">
	<li><a href="http://www.sbrac.org/">patchvonbraun</a> (Marcus Leech)'s <a href="https://www.cgran.org/svn/projects/multimode">multimode</a>:<ul>
		<li>AM, FM, USB, LSB , WFM. TV-FM, PAL-FM. Very nice, easy to use (screenshots: <a href="http://www.superkuh.com/gnuradio/multimode_new.png">main</a>, <a href="http://www.superkuh.com/gnuradio/multimode_scan.png">scanning</a>). It has an automated scanning and spectral zoom features with callbacks to click on the spectrogram or panorama to tune to the frequency of interest. There's a toggle for active gain control too. The way to get it is,</p>
<pre>svn co <a href="https://www.cgran.org/svn/projects/multimode">https://www.cgran.org/svn/projects/multimode</a></pre> <p>then instead of using GRC, just run the multimode.py as is.</p>
<pre>make install
python multimode.py</pre>
<p>If you run it outside of the svn created directory you might need to append ~/bin to pythonpath to find the helper script. If you used build-gnuradio it'll tell you what this is at the end of the install.</p>
<!--<pre>Please make sure your PYTHONPATH includes /home/superkuh/bin
And also that PATH includes /home/superkuh/bin
this will allow multimode to work correctly</pre>
<pre>PYTHONPATH=$PYTHONPATH:/usr/local/lib/python2.6/dist-packages:~/bin</pre>
-->
<p>Alternately set it in your ~/.bashrc. If you do the below make sure to reload in the terminal by "source ~/.bashrc")</p>
<pre>PYTHONPATH=/usr/local/lib/python2.6/dist-packages:~/bin
export PYTHONPATH;</pre>
<p><!-- With the old version (pre 05-30-2012 <a href="http://www.superkuh.com/gnuradio/multimode.png">screenshot</a>, <a href="/gnuradio/multimode_old.py">multimode_old.py</a>, <a href="/gnuradio/multimode_old.grc">multimode_old.grc</a>) without automatic scanning I can set the sample rate to 2.8 MS/s and it worked. In the newer version on my machine there are too many overruns (where it outputs "OOOO...") to do this. But if you have a fast machine it should be no problem.--> When setting the sample rate it is rounded-down to a multiple of 200 Ksps so the decimation math works out.</p>
<pre>python multimode.py --srate=2.4M # use normal mode with 2.4 MHz bandwidth
./multimode.py --devinfo="rtl=0,direct_samp=1" # use direct sample mode
<a href="/gnuradio/multimode_help.txt">python multimode.py --help</a></pre>
<p>If you have overruns like "OOOOoo..." then try reducing the sample rate or pausing the waterfall or spectrum displays.</p>
<p class="quote">"The audio subsystem uses 'a' as the identifier, and UHD uses 'u'.  With RTLSDR, it'll issue 'O' when it experiences an overrun.  Which means that your machine isn't keeping up with the data stream.  Sometimes buffering helps, but only if your machine is right on the edge of working properly.  If it really can't, on average "keep up", no amount of buffering will help."</p>
<p>If you have overruns like "aUaUaUaUa" or just "aaa" then the audio system is asking for samples at a higher rate than the DSP flow can provide (44vs48Khz, etc). Use "aplay -l" to get a list of the devices on your system.</p>
<pre>aplay -l
</pre>
<p> The hw:X,Y comes from this mapping of your hardware -- in this case, X is the card number, while Y is the device number. Or you can use "pulse" for pulseaudio. Try specifying,</p>
<pre>python multimode.py--ahw hw:0,0</pre>

</li>
		</ul>
	</li>


<a name="gqrxappnote">
	<li><a href="http://gqrx.dk/">gqrx</a>:<ul>
		<li>Written by <a href="https://github.com/csete/gqrx">Alexandru Csete OZ9AEC</a> "gqrx is an experimental AM, FM and SSB software defined receiver". The original version did not have librtlsdr support so changes were made by a number of others to add it. A couple weeks later Csete added gr-osmosdr support to the original. Dekar established a <a href="http://dekar.wc3edit.net/2012/09/30/osx-port-of-the-awesome-gqrx-sdr-software/">non-pulseaudio port of gqrx for Mac OSX</a>. GNU Radio 3.7 has recently been released and it is not exactly backwards compatible. patchvonbraun's build-gnuradio.sh pulls <s>3.6.5</s> 3.7.x by default. <!--You need to pull 3.7 with build-gnuradio's "-m" switch for the most recent gqrx.--> <!--I had to make changes to the Qt date function to be compatible old Qt libs on Ubuntu 10.04. (<a href="http://www.superkuh.com/gnuradio/gqrx_2.png">screenshot</a>)-->

<p>As of August 9th 2013 <a href="http://gqrx.dk/news/gqrx-2-2-0-released">Gqrx 2.2.0 has been released</a>. This upgraded version can now be installed as binaries with all of it's dependencies pre-packaged on both Ubuntu linux (a <a href="https://launchpad.net/~gqrx/+archive/releases">custom PPA</a>, no 10.04 packages) and Mac OS X! That includes all the GNU Radio stuff. So this is an all-in-one alternative to building GNU Radio from source.</p>

<p>I think <a href="http://www.linuxwolfpack.com/RTL-SDR.php">this person's guide</a> is better than mine.</p>

<!--git clone <a href="https://github.com/mathisschmieder/gqrx">https://github.com/mathisschmieder/gqrx</a>-->
<pre>git clone <a href="https://github.com/csete/gqrx.git">https://github.com/csete/gqrx.git</a>
cd gqrx
# on Ubuntu/Debian, sudo apt-get install qtcreator , if you don't have it.
qtcreator gqrx.pro 	# press the build button (the hammer)
# or avoid qtcreator and do it manually. if you have qt5 too, use "qmake-qt4"
qmake
make
</pre>
</li> 

<li><a href="http://talk.maemo.org/showthread.php?t=91182">rtlsdr w/Gqrx on N900 phones</a><ul>
	<li>xes provides pre-compiled packages of Gqrx and the GNU Radio dependencies for N900 linux cell phones.</li>
    </ul>
</li>
		</ul>
	</li>

<br />

<a name="sdrsharpappnote">
<li><a href="http://sdrsharp.com/">SDR#</a>: <ul>
	<li>Written by prog (Youssef) for <a href="http://rtlsdr.org/softwarewindows">Windows</a>. It is probably the best general purpose software for rtlsdr devices.<!-- It is updated very often as well. At the <a href="http://www.rtlsdr.org/">rtlsdr.org</a> wiki there is a guide to <a href="http://www.rtlsdr.org/softwarelinux">running the original C# version under linux with mono</a> but that only works for <em>old</em> versions. Instead look at ryan_turner's example install at <a href="http://pastebin.com/tgYwRBQt">http://pastebin.com/tgYwRBQt</a> (<a href="/gnuradio/sdrsharp_install.sh.txt">local mirror</a>).--> Mono is slow and ugly on linux but if you restrict the sample rate it works fine.<!-- When I try it <a href="/sdrsharp.txt">says it finds the E4000 tuner</a>, but then when I select the front-end it reports, "RTL-SDR / RTL2832U is either not connected or its driver is not working properly" and "usb_claim_interface error -6" (LIBUSB_ERROR_BUSY). This isn't changed by unplugging the dongle or rebooting. Lots of other people have no problems, though.--> It's probably the easiest program to use, has the most diverse plugin ecosystem (example: <a href="http://rtl-sdr.ru/page/vse-dostupnye-na-etom-sajte-plaginy-s-kratkim-opisaniem">Vasili_ru's plugins</a>), and has the best DSP and features for dealing with the quirks of the rtlsdr dongles.<!-- As of 2012-10-07 it also has GUI toggles for the direct sampling mode to listen to &lt;30Mhz signals. In 0.25 MS/s mode it can even run on my old 1.8Ghz P4 laptop.--> <!--On linux the waterfall doesn't "fall" for me. Instead the entire vertical space just shows the current frame. Others report resizing the window sometimes fixes this but I haven't been able to find the sweet spot.--> <!--To use it run rtl_tcp first then connect to the stream in sdr#.--> <!--To use the USB plugin make sure it's in the same directory and then uncomment it's line in SDRSharp.exe.config.--> <!--Whenever you're having trouble with decoding digital modes try setting 'minoutputsamplerate' in the sdrsharp.exe.config file to 48000khz and uncheck filter audio in the audio section.--><br />

<p>As of 2015-09-14 the changes to Mono 4 allow SDR# to be viable to run on linux again. Make sure you have the latest <a href="http://www.mono-project.com/docs/getting-started/install/linux/#debian-ubuntu-and-derivatives">Mono 4</a> though. This still requires soft linking in your system rtlsdr and portaudio library to the sdrshape.exe dir like below,</p>
<pre>ln -s  /usr/local/lib/librtlsdr.so librtlsdr.dll
ln -s /usr/lib/x86_64-linux-gnu/libportaudio.so.2 libportaudio.so</pre>

<p>Just make sure you link your actual system rtlsdr and libportaudio, not my example path above. On debian/ubuntu find it by using locate,</p>
<pre>locate portaudio.so</pre>
<p>Roklobsta's rtlsdr.org has <a href="http://rtlsdr.org/softwarelinux">a more detailed SDR# linux configuration guide</a> if you're having trouble.</p>
<!--
<p>It also requires a minor addition to plugins.xml,</p>
<pre> &lt;add key="AIRSPY" value="SDRSharp.AirSpy.AirSpyIO,SDRSharp.AIRSPY" /&gt;</pre>
-->
<!--

<hr />

As of July 2014 there have been many, many updates to SDR# since I last used it on linux. The below instructions may no longer apply. I hear that <a href="http://pastebin.com/X1ZsbDz5">this set of instructions</a> and patch that BzztPloink of ##rtlsdr put together will work though.<br /><br />

To compile it on Ubuntu 10 or 12 consult KJ4EHD ryan_turner's <a href="http://pastebin.com/tgYwRBQt">http://pastebin.com/tgYwRBQt</a>. Don't execute this because it is old. The "Release" dir hardcoded in is now "Debug".<br />
<pre>sudo apt-get install subversion git mono-complete libportaudio2 monodevelop icoutils
svn checkout https://subversion.assembla.com/svn/sdrsharp/
cd sdrsharp/trunk</pre>
<p>yulian's comment tipped me off that SDRSharp.sln has to be edited for older versions of mono (like from Ubuntu 12.04). Open it and change Microsoft Visual Studio Solution File, Format Version 12.00 to 11.00 and Visual Studio 2012 to 2010 and it will compile.</p>
<pre>mdtool build -c:Release SDRSharp.sln
cd Release
ln -s  /usr/local/lib/librtlsdr.so librtlsdr.dll
ln -s /usr/lib/x86_64-linux-gnu/libportaudio.so.2 libportaudio.so
 
# modify config
sed -i '/SDRSharp.SoftRock.SoftRockIO,SDRSharp.SoftRock/d' SDRSharp.exe.config
sed -i '/SDRSharp.FUNcube.FunCubeIO,SDRSharp.FUNcube/d' SDRSharp.exe.config
sed -i '/SDRSharp.FUNcubeProPlus.FunCubeProPlusIO,SDRSharp.FUNcubeProPlus/d' SDRSharp.exe.config
sed -i '/SDRSharp.RTLTCP.RtlTcpIO,SDRSharp.RTLTCP/d' SDRSharp.exe.config
sed -i '/SDRSharp.SDRIQ.SdrIqIO,SDRSharp.SDRIQ/d' SDRSharp.exe.config
sed -i 's/&lt;!-- &lt;add key="RTL-SDR \/ USB" value="SDRSharp.RTLSDR.RtlSdrIO,SDRSharp.RTLSDR" \/&gt; --&gt;/&lt;add key="RTL-SDR \/ USB" value="SDRSharp.RTLSDR.RtlSdrIO,SDRSharp.RTLSDR" \/&gt;/' SDRSharp.exe.config</pre>

-->

<!--<p>As of Sun May 5th 2013 there's a test version with an amazing new <a href="http://sdrsharp.com/downloads/dnr.png">noise reduction algorithm</a> (for voice?) at: <a href="http://sdrsharp.com/downloads/sdrsharp.dnr.zip">http://sdrsharp.com/downloads/sdrsharp.dnr.zip</a></p>-->

<a name="adbssharpappnote">
<li><b>Update: As of 2015-10-15 ADBS# is no more. </b><a href="http://sdrsharp.com/downloads/adsbsharp.zip">ADBS#</a> is another easy to use application by prog, but specifically for plotting aviation transponders like gr-air-modes does. The distributed binaries also runs under linux with mono (or native in windows) and output virtualradar compatible data on 127.0.0.1:47806. If your antenna condition is crappy, try using filter = 1.</li><br />
</ul>
</li>

<a name="grfosphor">
<li><a href="https://sdr.osmocom.org/trac/wiki/fosphor">gr-fosphor</a>:
	<ul><li>gr-fosphor is an amazingly fast and information dense spectrogram and waterfall visualization using OpenCL hardware acceleration. It surpasses the Wx widget elements in performance, and so usability, by far. With this visualization you can easily skip through 1 GHz of spectrum very quickly and actually notice transient signals as they pass. Right now it is not very configurable, just arrow keys for scale. But expect this to be the preferred visualization block in the future. I have written up an <a href="/install_gr-fosphor.txt">barebones guide to installing gr-fosphor on Ubuntu 12.04</a>. Modern gr-fosphor requires OpenCl 2. If you only have OpenCl 1.2 installed use <a href="https://github.com/osmocom/gr-fosphor/tree/b17258f1fc4ccc7859839a048916c8ad355c1e4c">this commit</a>.</li></ul>
</li><br />


<a name="grairmodesappnote">
	<li><a href="https://github.com/bistromath/gr-air-modes">gr-air-modes</a>: 
	<ul>
		<li> A decoder of aviation transponder <a href="http://en.wikipedia.org/wiki/Mode_S#Mode_S">Mode S</a> including ads-b reports near 1090 Mhz. It can be coupled to software to show plane positions in near real time (ex: <a href="http://www.virtualradarserver.co.uk/Default.aspx">VirtualRadar</a>). This works under mono on Ubuntu 12.04 but not 10.04. <a href="https://github.com/bistromath/gr-air-modes">Originally written</a> by Nick Foster (bistromath) and adapted to rtlsdr devices first by Steve Markgraf (stevem), bistromath later added rtlsdr support. Here's an example of basic <a href="/airplanes.txt">decoding done with the stock antenna</a> on the early version by stevem. Nowdays it's better to use bistromaths'. <!-- and logging <a href="http://superkuh.com/gr-air-modes_live2.txt">live</a>--> <!--(currently on 2012-06-03 @ 4:12pm CST (16:12 UTC) .-->
<!--		<pre>git clone https://github.com/steve-m/gr-air-modes.git</pre> -->

<p><em>As of July 23, 2013</em> there was a <a href="http://www.reddit.com/r/RTLSDR/comments/1iv8ho/grairmodes_major_updates/">major update</a> to gr-air-modes which now includes a nice <a href="http://i.imgur.com/5Zhytm5.jpg">google maps overlay</a> and <strong>works on gnu radio 3.7 branch only</strong>.</p>

		<pre>git clone https://github.com/bistromath/gr-air-modes.git</pre>
Here's an <a href="/gnuradio/gr-air-modes_install.txt">example of install process and first run looks like</a>.
<pre># -d stands for rtlsdr dongle, location is "North,East"
uhd_modes.py -d --location "45,-90"</pre>
To use with virtual radar output add the below -P switch. Then open up virtualradar with mono and go to tools-&gt;options-&gt;basestation and put in the IP of the computer running uhd_modes. There are not many <a href="http://en.wikipedia.org/wiki/Automatic_dependent_surveillance-broadcast#U.S._implementation_timetable">compatible planes in the USA</a> so far so even if you are seeing lots of Mode-S broadcast in uhd_modes you might not see anything in virtualradar. Sometimes my server is running at <a href="http://superkuh.com:81/VirtualRadar/GoogleMap.htm#">superkuh.com:81/VirtualRadar/GoogleMap.htm</a>.<pre>uhd_modes.py -d --location "45,-90" -P
mono VirtualRadar.exe</pre>

<!--<p>Modesbeast has a <a href="http://www.modesbeast.com/g7rgq.html">diagram of a colinear antenna</a> for this purpose</a>.</p>-->
		</li>
	</ul>
	</li>


<a name="dump1090appnote">
<li><a href="https://github.com/antirez/dump1090">Dump1090</a>:
	<ul>
	<li>
		<p class="quote"> Dump 1090 is a Mode S decoder specifically designed for RTLSDR devices.</p>
		<p>Antirezs' ADS-B program is really slick. It does not depend on GNU Radio, has a number of interactive modes, and it even optionally runs it's own HTTP server with googlemaps overlay of discovered planes; no virtualradar needed. It uses very little CPU and has impressive error correction. This is your best choice to play with plane tracking quickly.</p>

<pre># run cli interactively and create a googlemaps server on localhost port 8080
./dump1090 --aggressive --interactive --net-http-port 8080
# submit plane data to a tracking server
./dump1090 --aggressive --raw | socat -u - TCP4:sdrsharp.com:47806</pre>
	</li>
	</ul>
</li>


<a name="linradappnote">
<li><a href="http://www.sm5bsz.com/linuxdsp/hware/rtlsdr/rtlsdr.htm">linrad</a>:
	<ul><li>A guide on how to use linrad with rtl-sdr, and a modification to the the librtlsdr e4000 tuner code to <a href="http://lists.osmocom.org/pipermail/osmocom-sdr/2012-July/000129.html">disable digital active gain</a>! <a href="http://www.reddit.com/r/RTLSDR/comments/vbcio/linrad_seems_so_far_to_support_rtlsdr_on_many/">reddit thread</a></p>
<p class="quote">"I tried <a href="http://lists.osmocom.org/pipermail/osmocom-sdr/2012-July/000140.html">various bits</a> blindly and found a setting that eliminates the AGC in the RTL2832 chip. That is a significant part of the performance improvement."</p>
<p>As of <a href="http://www.reddit.com/r/RTLSDR/comments/w716g/new_rtlsdr_release_with_disabled_agc_thanks_to/">2012-07-07</a> this feature was added to the main (librtlsdr) driver as well.</li>
    	</ul>
</li>


<a name="ltecellappnote">
<li><a href="https://github.com/Evrytania/LTE-Cell-Scanner">LTE Cell Scanner</a> and <a href="http://www.evrytania.com/lte-tools/lte-tracker">LTE Tracker</a>:<ul>
	<li>
<p class="quote">"This is an <a href="https://en.wikipedia.org/wiki/LTE_(telecommunication)">LTE</a> cell searcher that scans a set of downlink frequencies and reports any LTE cells that were identified. A cell is considered identified if the MIB can be decoded and passes the CRC check."</p>
<p class="quote">"LTE-Tracker is a program that continuously searchers for LTE cells on a particular frequency and then tracks, in realtime, all found cells. With the addition of a GPS receiver, this program can be used to obtain basic cellular coverage maps."</p>
<p>The author had only tested it on Ubuntu 12.04 but with some frustrating work replacing cmake files and compiling dependencies <a href="#ltescanner">I made it work on 10.04</a>. Scanner is very useful to get your dongle's frequency offset reliably and Tracker is very pretty. Remember to let your rtlsdr dongle warm up to equilibrium temperature before checking frequency error.</p>
</li>
</ul>
</li>


<a name="kalibrateappnote">
<li><a href="https://github.com/steve-m/kalibrate-rtl">kalibrate-rtl</a>:<ul>
	<li>
<p class="quote">"<a href="http://thre.at/kalibrate">Kalibrate</a>, or kal, can scan for GSM base stations in a given frequency band and can use those GSM base stations to calculate the local oscillator frequency offset."</p>
<p>The code was written by Joshua Lackey and made rtlsdr accessible by stevem. There is also a <a href="http://rtlsdr.org/files/kalibrate-win-release.zip">windows build</a> made by Hoernchen. Let your rtlsdr dongle warm up to equilibrium temperature before running the test. When you're using this to find your frequency error it's important to use the -e option to specify intial error. 270k of bandwidth is used for GSM reception and if the error of the dongle is too large the FCCH-peak is outside the range. I compiled some install process and example usage <a href="/gnuradio/kalibrate-rtl_install_example_notes.txt">notes</a>.</p>
</li>
</ul>
</li>


<a name="simplefmappnote">
<li><a href="https://www.cgran.org/browser/projects/simple_fm_rcv/trunk">Simple FM (Stereo) Receiver</a><ul>
	<li>simple_fm_rcv also by patchvonbraun is the best sounding and tuning commercial FM software in my opinion. He released a major update to his gnuradio creation at the end of October. 
<pre>svn co https://www.cgran.org/svn/projects/simple_fm_rcv
cd simple_fm_rcv/
cd trunk
less README
make
make install
## it'll install to ~/bin/, so I use ~/superkuh/bin below
set PYTHONPATH=/usr/local/lib/python2.6/dist-packages:/home/superkuh/bin
# run the python script
python simple_fm_rcv.py
# or edit it
gnuradio-companion simple_fm_rcv.grc</pre>
</li>
    </ul>
</li>


<a name="dongleloggerappnote">
<li>my <a href="#pyrtlsdr_logger">DongleLogger</a>:<ul>
	<li><p>I wrote these scripts do automatic generation of 1D spectrograms, per frequency time series plots of total power, and 2D spectral maps over arbitrary frequency ranges using multiple dongles at once. There is almost no DSP done and it is very simple but the wideband spectrograms and time series can be informative and fun regardless. It uses gnuplot for graphics generation. <b>Obsolete. Use rtl_power instead</b>.</p>
<!--<p>To do this I added a pair of frequency correction get/set functions to the excellent <a href="https://github.com/roger-/pyrtlsdr">pyrtlsdr</a> wrapper for librtlsdr to use within a simple spectrogram and signal strength logger, graphfreqs.py. In order to automate and parse the output from the python script based on pyrtlsdr I switched to perl and wrote radioscan.pl. This script makes batches of calls to graphfreqs. These calls optionally include parsing and sending frequency offset corrections to graphfreqs from LTE Cell Scanner, gnuplot generation of time series and spectral map plots of power, and optional auto-generation of html galleries with png spectrograms linked to their ascii log files or the gnuplot time series pngs.</p>-->
<p>You can see a typical gallery output at, <a href="http://erewhon.superkuh.com/gnuradio/live/">http://erewhon.superkuh.com/gnuradio/live/</a> but more useful are the <a href="/gnuradio/live/spectral-map.png">gnuplot spectrograms</a> it can make.</p></li>
    </ul>
</li>




<a name="simple_ra" />
<li><a href="https://github.com/patchvonbraun/simple_ra">simple_ra</a>: simple radio astronomy<ul>
	<li><p class="quote">A simple, GRC-based tool for small-scale radio astronomy, providing both Total Power and Spectral modes. It has a graphical stripchart display, and a standard FFT display. It also records both total-power and spectral data using an external C program that records the data along with timestamps based on the Local Mean Sidereal Time.</p>
	<p>This is another incredible tool by patchvonbraun. It does all the heavy lifting of integration over time and signal processing to get an accurate measurement of absolute power over a range. With it he has managed to pick out the transit of the milky way at the neutral hydrogen frequency using rtlsdr sticks and a pair of yagi antenna. The log file format is text and fairly easy to parse with gnuplot but it comes with 'process_simple_tpdat' for cutting it into the bits you want and making total power or spectral component graphs. It'll make a directory called "simple_ra_data" in your home by default.<!--The stripchart implementation is a bit hacky because GRC isn't meant for making end user apps so sometimes the time axis labels will not change with the zoom. It's best not to zoom.--> Don't forget to set the --devid to rtl otherwise gnuradio won't find the gr-osmosdr source and it'll substitute a gaussian noise source.</p>

<!--svn co https://www.cgran.org/svn/projects/gr-ra_blocks-->
<!--svn co https://www.cgran.org/svn/projects/simple_ra-->
<pre>git clone https://github.com/patchvonbraun/gr-ra_blocks
cd gr-ra_blocks/
cmake . ; make ; sudo make install ; sudo ldconfig
cd ..
git clone https://github.com/patchvonbraun/simple_ra
cd simple_ra;
make
make install

# Using a single E4k tuner
./simple_ra --devid rtl=0,offset_tune=1 --longitude -45
# Using a second dongle that just happens to have a R820T tuner
./simple_ra --devid rtl=1 --longitude -45
# Use direct sample mode @ 1.25 MHz, log once per second, set longitude
./simple_ra --devid rtl=0,direct_samp=1 --freq 1.25e6 --longitude -90 --lrate 1
# generate multi-day averaged gnuplots using sidereal time
process_simple_tpdat 02:00:00 2.0 -t "11 GHz Test" -f 11ghz.png ~/simple_ra_data/tp-20130329-*.dat ~/simple_ra_data/tp-20130328-*.dat ~/simple_ra_data/tp-20130327-*.dat
<a href="/gnuradio/simple_ra-help.txt">./simple_ra -h</a> (<a href="/gnuradio/simple_ra_readme.txt">README</a>)
</pre>

<!--<p>There were changes made in the Makefile that <em>required</em> new versions of GNU Radio to include the grcc switches used in compiling. Update GNU Radio if you get "grcc: error: no such option: -d". (-d sets the output directory where the resulting .py file goes)</p>-->
	</li>
    </ul>
</li>


<a name="rtlsdrscannerappnote">
<li><a href="https://github.com/EarToEarOak/RTLSDR-Scanner">RTLSDR-Scanner</a><ul>
	<li><p>Ear to Ear Oak made this wideband total power scanner that generates 1D spectrum plots over any tunable ranges with arbitrary integration times. It can update a matplotlib python plot GUI in real time and has the ability to output cvs values as well as an internal format. It's very useful for finding what's broadcasting in your area quickly. Using it's csv output and gnuplot I visualized a scan from <a href="http://erewhon.superkuh.com/gnuradio/54-1100_discone.png">54-1100 MHz</a>.</p>

<p>If you want to use the data in gnuplot you have to sort it and make sure the header is commented out.</p>
<pre>sort -n 54-1100_500ms.csv &gt; sorted_54-1100_500ms.csv</pre>
<p>Here are some <a href="/gnuradio/gnuplotexample.txt">example gnuplot formats</a> for the data.</p>
<p>You can comment out the header manually but I instead prefixed a hash to the log writing behavior at line 786,</p> 
<pre>handle.write("# Frequency (MHz),Level (dB)\n")</pre>
</li>
    </ul>
</li>
</ul>


<!--
<li><a href=""></a><ul>
	<li></li>
    </ul>
</li>
-->

<h4>Pager stuff</h4>
<ul>
<li>Thomas Sailer's <a href="#pager">multimon</a>, "Linux Radio Transmission Decoder" which I use to (try to) decode pager transmissions around 930Mhz. <!--For my version of sox, upon which it depends for reading wav, an edit of a command line switch it passes to sox in unixinput.c is required. [edit] After emailing the author he has fixed it.--> And more recently <a href="http://dekar.wc3edit.net/2012/05/24/multimonng/">Dekar</a>'s <a href="https://github.com/EliasOenal/multimonNG.git">multimonNG</a>, a fork with improved error correction, more supported modes, and *nix/osx/windows support. Dekar also supplied a <a href="http://www.superkuh.com/gnuradio/pager_fifo.grc">GRC receiver for pagers</a> to <a href="#pager_realtime">decode pager transmissions in real-time using fifos</a>. zarya has made <a href="https://github.com/zarya/sdr/blob/master/receivers/rtl_flex.py">rtl_flex.py</a>, a gnuradio based flex decoder for pagers. It can be used to decode dutch p2000 messages, for example. This fills a gap in multimon-ng pager support.</li>
</ul>

<a name="pyrtlsdr_logger" />
<hr />
<h4>DongleLogger: my pyrtlsdr lib based spectrogram and signal strength log and plotter</h4>


<a href="http://superkuh.com/gnuradio/live/spectral-map.png"><img src="http://erewhon.superkuh.com/spectral-map_inline.png" /></a>


<!--<a href="http://www.superkuh.com/gnuradio/live/"><img src="/spectral-map_sm.png" /></a>-->

<!--<img src="http://www.superkuh.com/gnuradio/live/892000000.png" />-->
<h4>Purpose:</h4>
<p><b>Obsolete. Use rtl_power instead.</b> Automatic generation of and html gallery creation of wideband spectrograms using multiple rtlsdr dongles to divide up the spectrum. It also produces narrow band total charts, and other visualizations.</p>
<h3>(not live): <a href="http://erewhon.superkuh.com/gnuradio/live/load.html">http://erewhon.superkuh.com/gnuradio/live/</a> - click the spectrograms for time series plot</h3>

<p>These scripts cause the rtlsdr dongle to jump from frequency to frequency as fast as they can and take very rough total power measurement. This data is stored in human readable logs and later turned into wideband spectrograms by calling gnuplot. In order to further increase coverage of any given spectrum range multiple instances of the script can be run at once in the same directory adding to the same logs. Their combined output will be represented in the spectrogram.</p>

<h4>Details:</h4>
<p>I don't know much python but the python wrapper for librtlsdr <a href="https://github.com/roger-/pyrtlsdr">pyrtlsdr</a> was a bit easier to work with than gnu radio when I wanted to do <em>simple things without a need for precision or accuracy</em>. Actualy receivers with processing could be made with it too, but not by me. This is the gist of what it does,</p>
<pre>power = 10 * math.log10(scan[freq]) = scan = self.scan(sdr, freq) = capture = sdr.read_samples(self.samples) = iq = self.packed_bytes_to_iq(raw_data) = raw_data = self.read_bytes(num_bytes)</pre>
<p>The pyrtlsdr library can be downloaded by,</p>
<pre>git clone https://github.com/roger-/pyrtlsdr.git</pre>
<p>I have used the "<a href="https://github.com/roger-/pyrtlsdr/blob/master/test.py">test.py</a>" matplotlib graphical spectrogram generator that came with pyrtlsdr as a seed from which to conglomerate my own program for spectrum observation and logging. Since I am not very good with python I had to pull a lot of the logic out into a perl script. So everything is modular. As of now the python script generates the spectrogram pngs and records signal strength (and metadata) in frequency named logs. It is passed lots of arguments.</p>
<p>These arguments can be made however you want, but I wrote a perl script to automate it along with a few other useful things. It can generate a simple html gallery of the most recent full spectral map and spectrograms with each linked to the log of past signal levels. Or it can additionally generate gnuplot time series pngs (<a href="http://www.superkuh.com/gnuradio/live/graph_107200000.png">example</a>) and link those intead of the raw logs. It also calls <a href="https://github.com/Evrytania/LTE-Cell-Scanner">LTE Cell Scanner</a> and parses out the frequency offset for passing to graphfreq.py for correction. I no longer have it running because of the processor usage spikes which interrupt daily tasks. In the past I'd have rsync updating the public mirror with a big pipe every ~40 minutes. <!--I switched to a <a href="/spiralantenna.html">spiral antenna</a> on day 253 of 2012.--></p>

<h5>Modifying pyrltsdr</h5>

<p>As it is pyrtlsdr does not have the get/set functions for frequency correction even if I sent the PPM correct from the perl script. Since the hooks (?) were <a href="https://github.com/superkuh/pyrtlsdr/blob/master/rtlsdr/librtlsdr.py">already in librtlsdr.py</a> (line 60-66) but just not pythonized in rtlsdr.py they were easy to add to the library. These changes are required to use frequency correction and make the int variable "err_ppm" available. I have probably shown that I don't know anything about python with this description.</p>

<p>I forked roger-'s pyrtlsdr on github and added them there for review or use, <a href="https://github.com/superkuh/pyrtlsdr/commit/ffba3611cf0071dee7e1efec5c1a582e1e344c61">https://github.com/superkuh/pyrtlsdr/commit/ffba3611cf0071dee7e1efec5c1a582e1e344c61</a>. I apologize for cluttering up the pyrtlsdr namespace with such trivial changes but I'm new to this and github doesn't allow for private repositories.</p>

<h5>What you should be using instead.</h5>
<ul>
<li><a href="https://github.com/keenerd/rtl-sdr/blob/master/src/rtl_power.c">rtl_power</a> was recently (2013-08-20) released by keenerd. It does most of what my scripts do, except much better, faster, and easier. I highly recommend you try it first.</li>
<li><a href="http://eartoearoak.com/software/rtlsdr-scanner">RTLSDR Scanner</a> by Ear To Ear Oak is awesome for generating 1D wideband spectrograms.</li>
<li>Enoch Zembecowicz made a polished and useful <a href="http://zembecowicz.blogspot.cz/2012/09/rtl2832u-sdr-logging-tool.html">sdr logging tool</a></li>
<li>Panteltje's <a href="http://panteltje.com/panteltje/xpsa/index.html">rtl_sdr_scan</a> is another tool like RTLSDR Scanner for 1D total power scans. It is a good reference for using librtlsdr with C.</li>
<li>If you are serious about measuring total power over one 2.5 Mhz range then <a href="#simple_ra">simple_ra</a>, or simple radio astronomy, is best.</li></ul>

<h1>Download</h1>

<h4>fast version: <a href="#faster">see below</a></h4>

<ul><li><a href="/donglelogger-faster.tar.gz">donglelogger-faster.tar.gz</a> - all needed files including pyrtlsdr</li>

<li>
<ul>
	<li><a href="/radioscan_faster.pl">radioscan_faster.pl</a> - pyrltsdr using script; frequency setting and incrimenting, sampling, and logging.</li>
	<li><a href="/graphfreqs_faster5.py">graphfreqs_faster5.py</a> - option passing, log parsing, plot making, frequency corrections wrapper, html image gallery generation</li>
	<li><a href="/graphfreqs_gnuplot.py">graphfreqs_gnuplot.py</a> - legacy functions</li>
</ul>
</li>

</ul>

<h4>slow version:</h4>

<ul>
<li><a href="http://superkuh.com/gnuradio/graphfreqs.py">graphfreqs.py</a> - pyrltsdr using script;  sampling, and logging</li>
<li><a href="http://superkuh.com/gnuradio/radioscan.pl">radioscan.pl</a> - manages graphfreqs, parses logs, makes plots, gets frequency corrections, generates gallery</li>
</ul>

<!--<p>Or you can download everything together (even the modified pyrtlsdr library) in a compressed archive: <a href="/donglelogger.tar.gz">donglelogger.tar.gz</a>. This file is old and buggy.</p>-->

</ul>

<a name="faster"><h3>The faster version</h3></a>

<h5>Speed ups, Inline C usb reset, and avoiding dongle reinitialization... (less options)</h5>

<h5>cli switches/options</h5>
<pre>-dev 1			:: rtlsdr device ID (use to pick dongle)
-g 30			:: gain
-s 			:: interval between center frequencies
-r 2400000		:: sample rate
-d2 /path/here		:: path to the directory to put logs, plots, gallery
-c 751			:: LTC Cell scanner frequency offset correction, takes freq in Mhz of base cell
-w			:: turn on web gallery generation
-p			:: turn on gnuplot time series charts for every freq (don't use to maximize speed)
-m			:: generate full range spectrogram using all.log (this is the most useful thing)
-mr "52-1108,1248-1400,1900-2200"	:: set of frequency ranges to plot as a another spectrogram</pre>


<p><!--I tried batch calling reinitializes the rtlsdr dongle every single read of samples. This is slow. The sane thing would be to skip perl altogether and do it in python. Unfortunately I am no good with python.--><!--When I first made my scripts I had perl generate the list of frequencies to scan through and do each individually calling a simple pyrtlsdr using script. That was slow.-->These two scripts do fast scans within python from x to y frequency. Enabled it with -fast and make sure to set start and stop frequency with -f1 and -f2. Do not use -flist with this option.</p>
<pre>$ while true; do perl radioscan_faster.pl -d2 /tmp/faster -f1 25 -f2 1700 -fast -g 30 -r 2400000 -s 1.2 -m -p; sleep 1; done;
Running graphfreq in non-batch fast mode 25 to 1700 Mhz at 1.2 Mhz spacings.
 Spectrograms and text output disabled.
Using LTE Cell Scanner to find frequency offset from 751 Mhz station...Found Rafael Micro R820T tuner
-44k frequency offset. Correcting -58 PPM.
Generating <a href="/1300mhzierd.png">spectral map</a>.

python ./graphfreqs_faster.py 40000000 2400000 30 -58 /tmp/faster 1700000000
Found Rafael Micro R820T tuner
... (repeat many, many times)
</pre>

<p>This is an example output "spectral map" (a spectrogram with a silly name).<p>

<img src="/1300mhzierd.png" />

<p>This example output above shows the overloading effects of using a wideband discone that picks up off-band noise. Each column is made up of small squares colored by intensity of the signal. Since the scripts start at the low frequency and sweep to high there is a small time delay between the bottom and top (see it more clearly <a href="/gnuradio/spectral-map_three-pass.png">zoomed in</a>). And this is represented as the slant of the row. Sometimes strong signals will swamp out others resulting in discontinuities displaying as small dark vertical bands. </p>

<p>Or fast (-fast) scan a smaller range with smaller range (-f1,-f2: 24-80Mhz), with smaller samplerate (-r: 250 Khz)  at smaller intervals (-s: 400Khz steps) with a gain of ~30. Only output a large spectrogram of all frequencies to the directory specified with -d2 as spectral-map.png. This example does not use frequency offset correct (-c) for even faster speeds.</p>
<pre>while true; do perl radioscan_faster.pl -d2 /home/superkuh/radio/2012-02-02_R820T_Discone_lowfreq -f1 24 -f2 80 -fast -g 30 -r 250000 -s 0.4 -m -p; sleep 1; done;
Running graphfreq in non-batch fast mode 24 to 80 Mhz at 0.4 Mhz spacings.
 Spectrograms and text output disabled.
Generating spectral map.

python ./graphfreqs_faster5.py 24000000 250000 30 0 /home/superkuh/radio/2012-02-02_R820T_Discone_lowfreq 80000000 400000
Found Rafael Micro R820T tuner
Exact sample rate is: 250000.000414 Hz</pre>

<h4>Combining multiple rtlsdr devices for greater speed</h4>

<pre>Full</pre>
<a href="/spectral-map_ryannathans.png"><img src="http://erewhon.superkuh.com/spectral-map_ryannathans_sm.png" /></a><br />
<pre>Zoom</pre>
<a href="/spectral-map_lines_ryannathans.png"><img src="http://erewhon.superkuh.com/spectral-map_lines_ryannathans_sm.png" /></a>

<p>By splitting up the spectrum into multiple smaller slices and giving them to multiple dongles the time required for one scan pass can be greatly improved. The above spectrogram is made with 2 dongles, one for the lower half and one for the upper. It is from <em><b>ryannathans who also contributed the code for for specifying device ID</b></em>. This is as simple as running the script twice but giving each instance a different "-dev" argument to specify device ID. You can run as many rtlsdr devices with my scripts as you wish (up to the USB and CPU limits). If they are using the same directory (-d2) their log data will be combined automagically for better coverage.</p>

<a href="/multidongle_spectrogram.png"><img src="/multidongle_spectrogram_sm.png" /></a>

<pre>while true; do perl radioscan_faster.pl -d2 /home/superkuh/radio/2013-06-09_multidongle -f1 25 -f2 525 -fast -g 40 -r 2400000 -s 1.2 -m -dev 0; sleep 1; done;
...
Found Rafael Micro R820T tuner</pre>

<pre>while true; do perl radioscan_faster.pl -d2 /home/superkuh/radio/2013-06-09_multidongle -f1 525 -f2 1025 1100 -fast -g 29 -r 2400000 -s 1.2 -m -dev 1; sleep 1; done;
...
Found Elonics E4000 tuner</pre>

<h5>Outlier signals skewing your color map scale?</h5>

<p>Sometimes I get corrupt samples that show a signal level of +60dB. These skew the scale of the output spectrograms. If I notice that they have occurred during a long run I'll use grep to find them and remove them manually. I replace the signal level with the level of the previous non-corrupt sample. In the future I'll build this kind of outlier removal in to the scripts, or sanity check before writing them.</p>

<pre>grep -rinP " (3|4|5|6)\d+\.\d+" *.log</pre>


<p>All the incremental improvements in speed I've made above are okay but not very easy to maintain with multiple script types (bash/perl/python). I'm slowly putting together an Inline C based perl wrapper for exposing librtlsdr's functions within a perl script to write this as a standalone in perl. This is slow work because I've never done anything like it before.</p>

<h5>rtlsdrperl - what if there were a perl wrapper for librtlsdr?</h5>
<p>Well, there never will be. But here's some example code anyway.</p>
<pre>#!/usr/bin/perl
use Inline C => DATA => LIBS => '-L/usr/local/lib/ -lrtlsdr -lusb';
use warnings;
use strict;

my $fuckingtest = get_device_name(0);
print "Device name: $fuckingtest\n";
my $fuckingtest2 = get_device_count();
print "# Devices: $fuckingtest2\n";

__END__
__C__
const char* rtlsdr_get_device_name(uint32_t index);
char * get_device_name(int count) {
	char* res = rtlsdr_get_device_name(count);
	return res;
}

uint32_t rtlsdr_get_device_count(void);
int get_device_count() {
	int hem = rtlsdr_get_device_count();
	return hem;
}
</pre>

<h4>Older version</h4> 

<h5>graphfreqs.py</h5>
<p>You have to have the modified pyrtlsdr with the get/set functions for frequency correction. <a href="https://github.com/Evrytania/LTE-Cell-Scanner">LTE Cell Scanner</a> should also be installed so the "CellSearch" binary is available. Then download the two scripts above and put them in the same directory. For large bandwidths sampled this feature, ppm error correction, has an unnoticably small effect but I wanted to add it anyway.</p>

<p>To call the spectrogram/log generator by itself for 431.2 Mhz at 2.4MS/s with a gain of 30 and frequency correction of 58 PPM use it like,</p>
<pre>python graphfreqs.py 431200000 2400000 30 58</pre>

<p>I've disabled the matplotlib (python) per frequency spectrogram plots for frequencies over 1 Ghz because there's not much going on up there. Also, the x-axis ticks and labels become inaccurate for some reason.</p>

<h5>Logs and format</h5>

<p>The signal strength logs, named by frequency (e.g. 53200000.log), use unix time and are comma seperated with newlines after each entry. In order of columns it is: unix time , relative signal level , gain in dB, PPM correction.</p>
<pre>1345667680.28 , -34.65 , 29 , 57
1345667955.59 , -34.67 , 29 , 57
1345668004.37 , -34.55 , 29 , 57
1345668110.06 , -33.88 , 29 , 57
</pre>

<p>It also generates a log file with all frequencies for use with gnuplot, all.log. This file has unixtime first, then frequency, then gain and ppm error.</p>
<pre>1347532002.5 52000000 -14.84 29.0 58
1347532004.88 53200000 -17.84 29.0 58
1347532007.04 54400000 -17.98 29.0 58
1347532009.04 55600000 -19.78 29.0 58
1347532011.02 56800000 -24.04 29.0 58
1347532012.98 58000000 -26.21 29.0 58
1347532014.92 59200000 -25.10 29.0 58</pre>

<h5>radioscan.pl</h5>

<p>The radioscan.pl script is used to automate calling graphfreqs in arbitrary steps. To generate plots and signal strength for 52 Mhz to 1108 Mhz with a gain of 30, sample rate of 2.4MS/s, and an interval between center frequencies of 1.2 Mhz, call it like,</p>
<pre>$ perl radioscan.pl -flist "52-1108,1248-2200" -g 30 -r 2400000 -s 1.2</pre>

<h5>cli switches/options</h5>
<pre>-flist "52-1108,1248-2200"  :: sets of frequency ranges to scan.
-g 30			:: gain
-s 			:: interval between center frequencies
-r 2400000		:: sample rate
-d1 /path/here 		:: path to where the scripts are if now pwd
-d2 /path/here		:: path to the directory to put logs, plots, gallery
-c 751			:: LTC Cell scanner frequency offset correction, takes freq in Mhz of base cell
-w			:: turn on web gallery generation
-p			:: turn on gnuplot time series charts for every freq
-m			:: generate full range spectral map using all.log
-mr "52-1108,1248-1400,1900-2200"	:: set of frequency ranges to plot as a another spectral map</pre>

<p><!--If not given options it'll default to the above. To enable time series plots using gnuplot add the -p switch. To enabled spectral map plots use the -m switch. To enable the webpage generation add the -w switch. To enable frequency correction using LTE Cell Scanner output use the -c switch with the frequency in Mhz as an argument.--> Because I can use the default directories I keep it running like the below, but anyone else should make sure to set -d2.</p>
<pre>$ while true; do perl radioscan.pl -flist "52-1108,1248-2200" -g 30 -r 2400000 -s 1.2 -w -c 751 -p -m -mr "<a href="/gnuradio/live/spectral-map_52-1108.png">52-1108</a>"; sleep 1; done;

Running pyrtl graphfreq batch job 52 to 1108 Mhz at 1.2 Mhz spacings.
Using LTE Cell Scanner to find frequency offset from 751 Mhz station...Found Elonics E4000 tuner
42.6k frequency offset. Correcting 56 PPM.
Generating <a href="http://www.superkuh.com/gnuradio/live/spectral-map.png">spectral map</a>.
Generating another spectral map over only <a href="/gnuradio/live/spectral-map_52-1108.png">52-1108</a>.

python ./graphfreqs_offset.py 52000000 2400000 30 56
Found Elonics E4000 tuner
python ./graphfreqs_offset.py 53200000 2400000 30 56
Found Elonics E4000 tuner
python ./graphfreqs_offset.py 54400000 2400000 30 56
Found Elonics E4000 tuner
...
python ./graphfreqs_gnuplot.py 316000000 2400000 30 56
Found Elonics E4000 tuner
Dongle froze, reseting it's USB device...
Resetting USB device /dev/bus/usb/001/017
Reset successful
python ./graphfreqs_gnuplot.py 317200000 2400000 30 56
Found Elonics E4000 tuner
..
Generating page, moving images.

starting rsync...</pre>

<!--<img src="/gnuradio/spectral-map_three-pass.png" /> -->

<h5>Tuner/USB freeze solution with unplugging</h5>

<h6>edit: as of Jan 5th 2013, librtlsdr has added soft reset functionality</h6>

<p>Since graphfreqs.py's initializing and calling of rtl-sdr happens so frequently there are sometimes freezes. To fix these the USB device has to be reset. In the past I would accomplish this by un and re-plugging the cord manually. But that meant lots of downtime when I was away or sleeping. So, I've added in a small C program to the perl script using Inline::C that exposes a function, resetusb(). It is used if the eval loop around the graphfreqs call takes more than 10 seconds. <em>This means you need Inline::C to run this script</em>. To look at the original C version with a good explanation of how to use it <a href="http://www.roman10.net/how-to-reset-usb-device-in-linux/">click here</a>.</p>
<pre>sub donglefrozen {
	my $usbreset;
	my @devices = split("\n",`lsusb`);
	foreach my $line (@devices) {
		if ($line =~ /\w+\s(\d+)\s\w+\s(\d+):.+Realtek Semiconductor Corp\./) {
			$usbreset = "/dev/bus/usb/$1/$2";
			resetusb($usbreset);
}}}</pre>
</pre>
<pre>__END__
__C__
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;linux/usbdevice_fs.h&gt;

int resetusb(char *dongleaddress)
{
	const char *filename;
	int fd;
	int rc;
	filename = dongleaddress;
	fd = open(filename, O_WRONLY);
	if (fd &lt; 0) {
		perror("Error opening output file");
		return 1;
	}
	printf("Resetting USB device %s\n", filename);
	rc = ioctl(fd, USBDEVFS_RESET, 0);
	if (rc &lt; 0) {
		perror("Error in ioctl");
		return 1;
	}
	printf("Reset successful\n");
	close(fd);
	return 0;
}
</pre>

<hr>

<a name="interferometer">

<div style="float:right;margin-left:1em;">
<h3>Page Sections</h3>
<ul>
<li>Intro (here)</li>
<li><a href="#implementation">Implementation</a>
	<ul>
	<li><a href="#software">Software</a>
		<ul>
			<li><a href="#download">GRC Flowgraphs</a></li>
			<li><a href="#scripts">Scripts</a></li>
		</ul>
	</li>
	<li><a href="#ccp">Computer Pointing</a></li>
	</ul>
</li>

<!--<li><a href="#interferometry">Interferometry</a></li>-->
<li><a href="#references">Reference</a></li>
</ul>

</div>

<a name="intro">
<h4>My rtlsdr receiver + w/gnuradio implementation of the 11 GHz VSRT solar interferometer</h4>

<img style="float:left;margin-right:1em;" src="http://erewhon.superkuh.com/dishes_sm.jpg">
<!--<img src="http://erewhon.superkuh.com/11GHz_interferometer.jpg">-->

<!--<div style="float:right;margin-left:0.5em;"><pre>$75 2x 18" satellite dishes w/mounts shipped
$10 2x Ku LNFB (PLL321 S-2, ~30ppm error)
$10 rtlsdr receiver (r820t or e4k, ~30ppm error)
$10 power combiner (cheaper ones work too)
$5 coaxial power injector (LPI 2200)
$20 coaxial power supply (LPI 188PS) + diodes
$20 100ft RG6 quadshield + F connectors
$130 Two Dish Position Motors (HH90)
$60 DVB-S PCI card (Skystar 2, DiSEqC 1.2)
$10 DiSEqC 1.2 switch
$80 PVC, metal stock, drill bits</pre></div>-->


<p>As far as I understand it, the  <a href="http://www.haystack.mit.edu/edu/undergrad/VSRT/">VSRT</a> design is a subset of intensity interferometer that uses the frequency error between multiple 11 GHz satellite TV "low noise downconverter block" (LNBF) clocks to create a beat frequency in the total power integrated. I am basically copying the MIT <a href="http://www.haystack.mit.edu/">Haystack</a> <a href="http://www.haystack.mit.edu/edu/undergrad/VSRT/">Very Small Radio Telescope</a> (VSRT) but replacing the discrete component integrator and USB video input device with an rtlsdr dongle. The idea is to spend as little on hardware as possible.</p>

<p>With modern LNBF the error between same model parts is about 30 ppm which results in beat frequencies of ~100 KHz at the 10 GHz of the mixers. With this kind of front-end there are no nulls but the fringe modulation can still be read out as variations in count of histogram bins that contain the beat frequency (in the total power fft). This intensity measurement proxy traces out the the envelope of the fringes and varies as a sinc function of distance between antenna. Knowing this and the distance can give you high angular diameter and position measurements of very bright radio sources.</p>

<pre>$75 2x 18" satellite dishes w/mounts shipped
$10 2x Ku LNFB (<a href="/library/Tools/mine/Inside-AVENGER-PLL-321S.pdf" >PLL321 S-2</a>, ~30ppm error, RDA3560 w/27Mhz xtal.)
$10 rtlsdr receiver (r820t or e4k, ~30ppm error)
$10 power combiner (cheaper ones work too)
$5 coaxial power injector (LPI 2200)
$20 coaxial power supply (LPI 188PS) + diodes
$20 100ft RG6 quadshield + F connectors
$130 Two Dish Position Motors (HH90)
$60 DVB-S PCI card (Skystar 2, DiSEqC 1.2)
$10 DiSEqC 1.2 switch
$80 PVC, metal stock, drill bits</pre>

<h5>Historical and other context.</h5>

<p>For a detailed mathematical explanation of VSRT see MIT Haystack's <a href="http://www.haystack.edu/edu/pcr/vsrt-ret/VSRT_Introduction_Summer2009.pdf">VSRT Introduction</a>.</a> There is also a <a href="https://groups.google.com/forum/#!topic/sara-list/KBZdgfHWY3Q">thread</a> on the Society for Amateur Radio Astronomers list discussing the VSRT design. The more general concept of intensity interferometry, where you correlate total power instead of frequency, was originally developed by Hanbury-Brown &amp; Twiss. Roger Jennison was around too. "<a href="http://books.google.com/books?id=v2SqL0zCrwcC&source=gbs_navlinks_s">The Early Years of Radio Astronomy: Reflections Fifty Years after Janskys Discovery</a>" by W T Sullivan (2005) is an excellent source about Hanbury Brown and Twiss's side of it. The chapter "<a href="/library/Space/Radio%20Astronomy/intensity-interferometry.pdf">The Invention and Early Devlopment of The Intensity Interferometer</a>" (pdf) is fascinating. Also see "<a href="/library/Space/Radio%20Astronomy/The%20Development%20of%20Michelson%20and%20Intensity%20Long%20Baseline%20Interferometry_%20R%20Hanbury%20Brown.pdf">The Development of Michelson and Intensity Long Baseline Interferometry</a>" (pdf). It covers not only the technical concepts but also historical context, detailed hands-on implementations, and other personal anectdotes. And check out Jennison's book "<a href="http://erewhon.superkuh.com/library/Space/Radio%20Astronomy/Radio%20Astronomy_%20Roger%20C%20Jennison_%201966.pdf">Radio Astronomy</a>" (1966)) as he invented the process of phase closure which uses a third antenna signal combined mathematically to recover some of the missing phase information. Arranged in a triangle of projected baselines the phase errors cause equal but opposite phase shifts in ajoining baselines, canceling out in the "closure phase". The MIT Haystack groups managed to <a href="http://www.haystack.mit.edu/edu/undergrad/VSRT/VSRT_Memos/024.pdf">resolve individual sunspots groups moving across the solar disk</a> using with the technique with the VSRTs.</p>

<br clear="all" />

<!--<a href="/tp-modes.grc"><img src="/tp-modes.png"></a>-->
<img style="float:left;margin-right:1em;margin-top:1em;" src="http://erewhon.superkuh.com/lnbf_intensity_interferometer_diagram.png" />

<hr style="margin-top:1em;" />

<p class="quote">"An interferometer is an instrument
that combines two signals (normally from two detectors) in a manner that the signals
interfere to produce a resultant signal. The resultant signal is usually the vector sum of the
two signals, but in some cases it is the product or some other mix. The traditional
interferometer, usually studied and analyzed in physics courses, combines the two signals
in a way that both amplitude and phase information are used. By varying the positions of
the two detectors, it is possible to synthesize an effective aperture that is equivalent to the
separation of the detectors and to reconstruct the impinging wavefront, thus providing
significant information about the extent and structure of the signal source. The
traditional phase-sensitive interferometer requires retention of the signal phase at each
detector  the phase-sensitive interferometry technique will not be discussed in detail
here."</p>
<p class="quote">"A special case of the interferometer is the intensity interferometer, which performs an
intensity correlation of signals from the two detectors. Although in the intensity
interferometer the phase information from the two antennas is discarded, the correlation
of the two signals remains useful. Aperture synthesis is not practical, but some important
source characteristics may be determined."</p>


<hr /><br clear="all" /> 



<p>I think the VSRT is a special case of intensity interferometer  where you don't try to align samples by time after recording. Instead you just look for the baseline distance sinc pattern in total power at the beat frequency of the unsynchronized clocks.</p>


<!--<p>Sun -&gt; 2x offset parabolic dishes -(10.7-11.7 GHz)-&gt; 2x 11 GHz LNBF -(950-1950 MHz GHz)-&gt; Power Combiner -&gt;
rtlsdr receiver -(1.6 GHz)-&gt; gnuradio sums total power -&gt; [gnuradio fourier transform -&gt;]
 Low pass filter w/10x-decimation-(0-200Khz)-&gt;  40 KHz bandpass @ beat frequency -(100KHz +-20KHz)-&gt; relative interferometric power</p>-->

<a name="implementation">

<h2>Implementation so far.</h2>

<p>So far I've only done it with manual pointing screwed to a board. The interferometry correlation is done with a satellite tv market stripline power combiner at the intermediate frequency (IF, ~950-1950 MHz) and then an rtlsdr dongle is used to measure the total power of a 2.4 MHz bandwidth of the intermediate frequency range. I use a gnuradio-companion flowgraph to take the total power and then do a fourier transform of the total power. In this fourier transform the fringes show up as a modulation of the count in the FFT bins which correspond to the difference in frequency between the two downconverters. In my case this is about ~100 KHz.<p>

<p>In the Haystack VSRT memos a line drop amplifier, or two, are sometimes put behind the respective LNBF IF coax outputs or the power combiner. With the rtlsdr dongle and relative short (&lt;10m) baselines of RG6 this isn't required.</p>

<a name="software">
<p>The GUI allows for setting the exact 2.4 MHz bandwidth of the IF range to sample and the total power FFT bin bandpass to where and what the LNBF beat frequency is. The file name is autogenerated to the format,</p>

<pre>prefix + datetime.now().strftime("%Y.%m.%d.%H.%M.%S") + ".log"</pre>

<p>The time embedded in the filename is later used by a perl script, vsrt_log_timeplot.pl, which converts and metadata tags the binary records to gnuplot useable text csv format for making PNG plots.</p>


<a name="download">
<h3>Download</h3>
<ul>
<li><a href="/tp-modes.grc">total power modes (tp-modes.grc)</a></li>
<li><a href="/vsrt_log_timeplot.pl">vsrt_log_timeplot.pl</a></li>
</ul>



<a href="http://erewhon.superkuh.com/gnuradio/myinterferometerflowgraph.png"><img src="http://erewhon.superkuh.com/gnuradio/myinterferometerflowgraph_sm.png"></a>

<h4>Who else helped</h4>

<!--<a href="/sim-intensity-interferometer.png"><img style="float:right;margin-left:1em;" src="/sim-intensity-interferometer_sm.png" /></a>-->

<a href="http://erewhon.superkuh.com/sim-intensity-interferometer-2.png"><img style="float:left;margin-right:1em;" src="http://erewhon.superkuh.com/sim-intensity-interferometer-2_sm.png" /></a>

<p>I consulted with patchvonbraun a lot for the software/gnuradio side. He gave me an example of how to use the WX GUI Stripchart and I would not have guessed I needed to square the values from the beat frequency bins <em>after</em> the first squaring for taking total power. He made a generic simulator for dual free running clocks LNBF intensity interferometers. You don't even need to have an rtlsdr device to run it; only an up to date install of gnuradio. It is an easy  way to understand how to do interferometry without a distributed clock signal.</p>

<p>patchvonbraun's: <a href="/gnuradio/simulated-intensity-interferometer.grc">simulated-intensity-interferometer.grc</a></p>

<!--<img src="/simulated-intensity-interferometer.png" />-->




<br clear="all" />

<h3>Physical</h3>

<a href="http://erewhon.superkuh.com/tp-modes_gui.png"><img style="float:left;margin-right:1em;" src="http://erewhon.superkuh.com/tp-modes_gui_sm.png"></a>

<p>With this setup on a 1 meter baseline and a intermediate tuning frequency of 1.6 GHz IF (10700 MHz+(1600 MHz950 MHz)= 11350 MHz) the main beamwidth would be about 70*(c/11GHz)/1m), or 1.9 degrees. This does not resolve the solar disk (~0.5 deg) during drift scans. <!-- I think that since it is an adding interferometer the sun will not "average out" even if my beamwidth makes it an extended source covered by mutiple sidelobes.--> <!--I will not see signs of individual active regions as that'll probably require an extended baseline of at least 4m.-->I have been told that the magnitude goes down in a SINC pattern as you widen the baseline and approach resolving the source but I will not resolve the sun initially. In the VSRT Memos "<a href="http://www.haystack.mit.edu/edu/undergrad/VSRT/VSRT_Memos/024.pdf">Development of a solar imaging array of Very Small Radio Telescopes</a>" a computationally complex way to resolve individual action regions is done with a 3rd dish providing "phase closure" in the array on a slanted north-south baseline in addition to the existing east-west baseline. I try to point my dishes so that the Earth is passing the sun through the beam at ~12:09pm (noon) each day. To aid in pointing a cross of reflective aluminum tape is applied center of the dish. This creates a cross of light on the LNBF feed when it is in the dish focal plane and the dish is pointed at the sun. The picture below is from later in the day, the one of the left shows the sun drifting out of the beam as it sets. I made my LNBF holders out of small pieces of wood compression fit in the dish arm. There are grooves for the RG6 coax to fit ground out with a rotary tool. The PVC collars have slots cut in the back with screws going into the wood to set the angle.</p>

<img src="http://erewhon.superkuh.com/light-cross-feed.jpg" />

<br clear="all" />

<p>The screenshot shows a short run near sunset on an otherwise cloudy day. The discontinuities are me running outside and manually re-pointing the dishes. But it does highlight how the beat frequency of the 2 LNBF varies as they warm up when turned on. It starts down at ~90 KHz but within 10 minutes it rises to ~115 KHz. After it reaches equilibrium the variation is ~ -+1 KHz. I could change the existing 80-120 KHz bandpass to a 110-120 KHz bandpass and have better sensitivity. But that bandwidth is something that has to be found empirically with each LNBF pair and set manually within the GUI for now.</p>

<p>patchvonbraun said it was feasible to identify the frequency bins with the most counts and that there was an example within the simpla_ra code,</p>
<p class="quote">"You could even have a little helper function, based on a vector probe, that finds your bin range, and tunes the filter appropriately."</p>

<p>The below close up of indoor testing showing how everything is connected on the rtlsdr side showing the power injector, e4k based rtlsdr (wrapped in aluminum tape), and the stripline based satellite power combiner for correlation. The two rg6 quadshield coaxial lines going from the power combiner to the ku band LNBF are as close to the same length as I could trim them.  I use a 1 amp 18v power supply and coaxial power injector to supply power to the LNB and any amplifiers. This voltage controls linear polarization (horiztonal/vertical) and it can be changed by putting a few 1 amp 1N4007 in series with the power line to drop the voltage.</p>

<img src="http://erewhon.superkuh.com/powerinjection.jpg">


<a name="scripts">

<h3>Accessory scripts.</h3>
<p>tp-modes.grc produces binary logs that are pretty simple. The count of the LNBF beat frequency bins in the bandpass are saved as floats represented as 4 pairs of hexadecimal. When the integration time is set to the default 1 second then one 4 byte data point is written to the log every 0.5 seconds. I highly recommend not changing this for now. There is no metadata or padding. Here's a screenshot of a run using the utility "bless",</p>

<img src="http://erewhon.superkuh.com/bless-vsrt.png" />

<p>In order to convert the binary logs of 4 byte records into something gnuplot can parse I use a simple perl script,</p>

<pre>#!/usr/bin/perl
use warnings;
use strict;

my $data = '/home/superkuh/vsrt_2013.06.13.12.26.47.log';
my $bytelength = 4; 
my $format = "f"; # floats (little endian)
my $num_records;

if ($ARGV[0]) {
	$data = $ARGV[0];
} else {
	print "you need to pass the log file path as an argument.";
	exit;
}

open(LOG,"$data") or die "Can't open log.\n$!";
binmode(LOG);

my $i = 0;
until ( eof(LOG) ) {
	my $record;
	my $decimal;
	read(LOG, $record, $bytelength) == $bytelength
		or die "short read\n";
	$decimal = unpack($format, $record);
	printf("$i,\t$decimal\n", $decimal);
	$i++;
}</pre>

<p>Now I have the filename which gives the time the gnuradio-companion grc file started running. This is <em>not</em> the time I hit the record button and started logging. The offset is a second or two. Ignoring that, it is possible to use the start time encoded in the log file name to figure out when a particular measurement was taken. To do that I have to know the interval between entries saved to the binary log.</p>

<pre>$ date && ls -l /home/superkuh/vsrt_2013.06.14.12.03.00.log && sleep 60 && date && ls -l /home/superkuh/vsrt_2013.06.14.12.03.00.log
Fri Jun 14 13:05:24 CDT 2013
-rw-r--r-- 1 superkuh superkuh 29644 2013-06-14 13:05 /home/superkuh/vsrt_2013.06.14.12.03.00.log
Fri Jun 14 13:06:24 CDT 2013
-rw-r--r-- 1 superkuh superkuh 30124 2013-06-14 13:06 /home/superkuh/vsrt_2013.06.14.12.03.00.log

((3012429644)/4)/60 = 2

$ date && ls -l /home/superkuh/vsrt_null.log && sleep 60 && date && ls -l /home/superkuh/vsrt_null.logFri Jun 14 13:44:36 CDT 2013
-rw-r--r-- 1 superkuh superkuh 8 2013-06-14 13:44 /home/superkuh/vsrt_null.log
Fri Jun 14 13:45:36 CDT 2013
-rw-r--r-- 1 superkuh superkuh 488 2013-06-14 13:45 /home/superkuh/vsrt_null.log

((4888)/4)/60 = 2</pre>

<p>To know what time a log record corresponds to, take the time from the filename and then add 0.5 seconds * the index of the 4 byte entry in the binary log. This should be possible to write into the until loop so it outputs time instead of just index $i. The below example is a hacky version of my log parser that does just this. Here's an <a href="/example_records.txt">example output</a>.</p>

<pre style="float:right;"># UTC Epoch	# Beat Freq Bins
1371229380.0,	1.38292284646013e-06
1371229380.5,	1.37606230055098e-06
1371229381.0,	1.374015937472e-06
1371229381.5,	1.366425294691e-06
1371229382.0,	1.35845414206415e-06
1371229382.5,	1.36476899115223e-06
1371229383.0,	1.36480070977996e-06
1371229383.5,	1.36444589315943e-06
1371229384.0,	1.35775212584122e-06
1371229384.5,	1.36395499339415e-06
1371229385.0,	1.35322613914468e-06
1371229385.5,	1.36412847950851e-06
1371229386.0,	1.36531491534697e-06
1371229386.5,	1.3664910056832e-06
1371229387.0,	1.36144888074341e-06
1371229387.5,	1.35596496875223e-06
1371229388.0,	1.35830066483322e-06
1371229388.5,	1.3654090480486e-06
1371229389.0,	1.358990175504e-06
1371229389.5,	1.37098015784431e-06
1371229390.0,	1.387945303577e-06
1371229390.5,	1.38286770834384e-06
1371229391.0,	1.36734763600543e-06
1371229391.5,	1.36036248932214e-06
...</pre>

<pre>#!/usr/bin/perl
use DateTime;
use warnings;
use strict;

# The simplest possible gnuplot plot using this program's output.
# ./vsrt_log_timeplot.pl /home/superkuh/vsrt_2013.06.14.12.03.00.log > whee2.log
# gnuplot> plot "./whee2.log" using 1:2 title "VSRT Test" with lines

my $data = '/home/superkuh/vsrt_2013.06.13.12.26.47.log';
my $bytelength = 4; 
#my $format = "V"; # oops, not this unsigned 32 bit (little endian)
my $format = "f"; # float
my $num_records;

if ($ARGV[0]) {
	$data = $ARGV[0];
} else {
	print "you need to pass the log file path as an argument.";
	exit;
}

my $dt; # declare datetime variable globally
extracttime($data); # $dt now has date object.

open(LOG,"$data") or die "Can't open log.\n$!";
binmode(LOG);

my $i = 0;
until ( eof(LOG) ) {
	my $record;
	my $decimal;
	read(LOG, $record, $bytelength) == $bytelength
		or die "short read\n";

	$decimal = unpack($format, $record);

	# This is a stupid/fragile way to deal with datetime
	# not having enough precision. It only works if the
	# record to record interval is always 0.5 seconds.
	my $recordtime = $dt->epoch();
	if (0 == $i % 2) {
		printf("$recordtime.0,\t$decimal\n", $decimal);
	} else {
		printf("$recordtime.5,\t$decimal\n", $decimal);
	}

	$dt->add( nanoseconds => 500000000 );
	$i++;
}

sub extracttime {
	my $timestring = shift;
	# /home/superkuh/vsrt_2013.06.13.12.26.47.log
	$timestring =~ /(\d{4}\.\d{2}\.\d{2})\.(\d\d\.\d\d\.\d\d)/;
	my $year_month_day = $1;
	my $time = $2;

	my ($year,$month,$day) = split(/\./, $year_month_day);
	$time =~ s/\./:/g;
	my ($hour,$minute,$second) = split(/:/, $time);

	$dt = DateTime->new(
		year       => $year,
		month      => $month,
		day        => $day,
		hour       => $hour,
		minute     => $minute,
		second     => $second,
		time_zone  => 'America/Chicago',
	);

	$dt->set_time_zone('UTC');
	return 1;	
}</pre>

<p>Now I just have to make up a good gnuplot format and integrate the calls into the perl script.</p> 

<!-- <a name="interferometry">
<h3>But where are the fringes?!</h3>
<p>Okay, I admit it. I don't have any yet. I'm getting there, though. Anyway, when I get all the software written and do start getting multiday averaged data and piping it into gnuplot this what I might see with respect to fringe modulation of counts in the FFT beat frequency bins.</p>

<pre>70*(c/11GHz)/1m) = 1.9 degree ~3dB beamwidth
(15 deg/hour)/(1.9 deg) = 7.9/hour 
(7.9/hour)/(60 min/hour) = 0.132 fringe/minute</pre>

<p>That doesn't resolve the sun and I'll need to expand my baseline to ~4m sometime.</p>

<pre>70*(c/11GHz)/4m) = 0.48 degree ~3dB beamwidth
(15 deg/hour)/(0.48 deg) = 31.25/hour 
(31.25/hour)/(60 min/hour) = 0.52 fringe/minute</pre>
-->

<a name="ccp">

<h2>Computer controlled pointing, mechanical and software differences</h2>


<img style="float:left;margin-right:1em;margin-top:1em;" src="http://erewhon.superkuh.com/MIT-Haystack-VSRT-Positioning.jpg" />

<a name="physical">
<p>Manually repositioning the dishes swamps out the signal of interest as the target leaves the beamwidth. For any decent measurements I need computer controlled pointing. This means the Haystack idea of two coupled Diseqc 1.2 compatible motor positioners mounted one on the other. In their design both dishes are mounted on a single PVC tube hooked to one of the positioners with a metal extension. My satellite dish mounts can't rotate like theirs so I'll have to <a href="http://erewhon.superkuh.com/sketch_11ghinterfereometer_fixed.png">modify this design a bit</a>. They use a serial relay to "push" the buttons on a physical Diseqc 1.2 motor controller remote. That seemed a bit convoluted to me. I bought a <a href="http://erewhon.superkuh.com/skystar2.jpg">SkyStar2 DVB-S pci card</a> and under linux send raw Diseqc commands out by calling <a href="http://panteltje.com/panteltje/satellite/">xdipo</a> which accesses the linux DVB interface. It has both a GUI and cli interface. Unfortunately xdipo cannot send through Diseqc switches. I had to add manual motor commands to <a href="https://bitbucket.org/CrazyCat/tune-s2">tune-s2</a> which did support switches but not manual motor commands. This version which supports manual stepping mode is available at <a href="https://github.com/superkuh/tune-s2-stepping">https://github.com/superkuh/tune-s2-stepping</a>.

<p>Another alternative Diseqc motor controller I didn't persue would be using a 192 KHz USB soundcard and the <a href="http://www.juras-projects.org/eng/software.php">DiSEqC Audio Generator</a> software from Juras-Projects. The documentation for the hardware side of the audio generator is 404 now, but <a href="/audiodiseqc.html">Juras responded to an email of mine with the schematics attached</a>.</p>


<!--<img style="float:right;margin-left:1em;margin-top:1em;" src="/sketch_11ghinterfereometer_sm.png" />-->

<a href="http://erewhon.superkuh.com/sketch_11ghinterfereometer_fixed.png"><img style="float:right;margin-left:1em;margin-top:1em;" src="http://erewhon.superkuh.com/sketch_11ghinterfereometer_fixed_sm.png" /></a>


<p>Since the bent motor shafts that came will my motors looked really difficult to drill through I thought I'd use straight hex holed shafts to make everything mechanically simpler. I found <a href="http://www.reidsupply.com/sku/HHS-18/">http://www.reidsupply.com/sku/HHS-18/</a> and ordered a couple. Unfortunately my measurements of the dish motor shaft flat-to-flate size were off. The Reid hex holed shaft hole is just a tiny bit too large. This was easily fixed by wrapping a couple turns of masking tape around the shaft to increase the diameter. This is often how fishing rod handles are made. I also encountered this construction technique on Jarrod Kinsey's <a href="http://www.jarrodkinsey.org/co2laser/co2laser.html">CO2 laser pages</a>.</p>

<p>The hardest part of all this is drilling an 8mm hole precisely normal to the curved outside surface of the hex hole shaft. The first step is to flatten the area with a hand file. This took me about 10 minutes. I had previously ordered and received two carbide drill bits, one small to sub-drill the intial hole and then one 8mm for the final hole. A drill press and small vice are quired to actually drill the holes. And even then it's really tricky. My first two attempts resulted in holes not quite normal to the surface of the hex flat. I could only use roll or taper pins to secure the shaft. Luckily I bought 2x shafts just in case.</p>

<p>I also had to drill 4 additional 8mm holes in the 2x satellite dish motor mounts to make holes for level mounting instead of at a tilt. The VRST guys got lucky with their sat motor mounts having a long slot.</p>

<p>The diameter of easily available PVC is slightly to small for the dish mounting clamp. This is remedied like the motor shafts; by wrapping wide masking tape to size and optionally epoxy coating/sanding it.</p>

<a href="http://erewhon.superkuh.com/motor-mechanics-zoom.png"><img src="http://erewhon.superkuh.com/motor-mechanics-zoom_sm.png" /></a> <a href="http://erewhon.superkuh.com/parts2.jpg"><img src="http://erewhon.superkuh.com/parts2_sm.jpg" /></a> <a href="http://erewhon.superkuh.com/parts.jpg"><img src="http://erewhon.superkuh.com/parts_sm.jpg" /></a> 
<a href="http://erewhon.superkuh.com/skystar2.jpg"><img src="http://erewhon.superkuh.com/skystar2_sm.jpg" /></a>

<p>The dish motors used in the VSRT project were Stab HH90. These have come down in cost since the VSRT memos were written and are still widely available.</p>

<pre> 065	<a href="http://www.ebay.com/itm/330858601252">Stab HH90</a> dish pointing motor #1
 065 	<a href="http://www.ebay.com/itm/330858601252">Stab HH90</a> dish pointing motor #2
$130 total</pre>

<p>In order to control these motors a system to send <a href="/library/Space/Radio Astronomy/Raw DiSEqC 1.2 commands_ BGonaSTICK.txt">DISEqC 1.2 commands</a> is needed. The first option would be to faithfully replicate the  VSRT implementation. They do it in a rather roundabout way but at least it is tested and known to work with their software. Unfortunately the specific hardware used has become rare, is mostly shipped from overseas, or is expensive.</p>

<pre> 045	<a href="http://ftaelectronic.com/store/index.php/satellite-hardware/motors/motor-positioners/stab-mp01-mini-positioner.html">STAB MP01</a> Positioner Control #1
 045	<a href="http://ftaelectronic.com/store/index.php/satellite-hardware/motors/motor-positioners/stab-mp01-mini-positioner.html">STAB MP01</a> Positioner Control #2
 080	<a href="http://www.weedtech.com/wtssr-m.html">WTSSR-M</a> Serial port Solid State Relay 
 000	VSRT Java software (windows)

 030	Two <a href="https://www.onlinemetals.com/merchant.cfm?pid=9668&step=4&showunits=inches&id=814&top_cat=197">5" x 9" x 0.125"</a> thick steel plates
 020	Two 15" x 1" x 0.125" thick aluminum counterweight arms
 020	Shipping for the metal parts.</pre>

<p>My chosen method of HH90 motor control is a single DVB-S card under linux with DVB API 5.x w/ my modified tune-s2 and optionally <a href="http://panteltje.com/panteltje/satellite/">xdipo</a>. This can be combined with a DiSEqC switch to scale to control of multiple motors relatively cheaply. I do sun alt-az position calculation by using a small <a href="http://pysolar.org/">pysolar</a> python script. I have not yet completed the scripts to turn alt-az positions of the sun at my location into motor step commands. Hopefully I can use some of the USAL fuctions in tune-s2 for that.</p>


<pre> 066	Skystar 2 HD pci card
 010	DiSEqC switch
 000	tune-s2 and xdipo DVB control software (linux)

 020	<a href="http://www.reidsupply.com/sku/HHS-18/">.753" Hex-Holed Sleeve</a>
 010	5" wide masking tape
 020	Two 15" x 1" x 0.125" aluminum counterweight arms</pre>

<p>Both require PVC pipe, tools like drills, 8mm drill bits and smaller sub-drill bit, hand saws, files, and potentially a welder (though liberal J-B Weld would probably work).</p>

<h3>Diseqc switches problems and solutions.</h3>

<p>It turns out that xdipo alone cannot deal with motors behind Diseqc switches. This means it can only control one Diseqc motor at once. Controlling two would require 2x Skystar 2 pci cards. Luckily there are other options. CrazyCat's <a href="https://bitbucket.org/CrazyCat/tune-s2">tune-s2</a> supports Diseqc switches and addressing. It normally only provides for motor commands using the <a href="http://en.wikipedia.org/wiki/Universal_Satellites_Automatic_Location_System">USAL</a> system which isn't too helpful. But I was able to modify the code to support manual motor position commands while retaining the switch support. xdipo could still be used in theory by calling tune-s2 to set the Diseqc switch to the appropriate port/motor and then calling xdipo as normal. But it is easier to just use the modified tune-s2 for everything.</p>

<p>This gutted version of tune-s2 for manual motor commands is available at:</p>

<h4><a href="https://github.com/superkuh/tune-s2-stepping">https://github.com/superkuh/tune-s2-stepping</a></h4>

<p>The functions I added are basically just look up arrays with Diseqc bus commands for different steps in the clockwise or counter-clockwise directions. In Diseqc the packets have 4 sections. Check out the Diseqc <a href="/library/Space/Radio%20Astronomy/Diseqc Bus Functional Specification_ EUTELSAT_ 1998.pdf">Bus Functional Specification</a> (pdf) for a better explanation with more detail.</p>

<img src="http://erewhon.superkuh.com/diseqc-packet.png" />

<p>The first, "Framing" byte represent if the command is from the receiver or diseqc device and wether it needs a reply. For my table these are all just "EO" which means it's a packet from the receiver with no response required. Most commands are EO but it goes up to E7. </p>

<p>The second, "Address" specifies which types of Diseqc devices should listen (ex: LNB, switch, motor, polarizer). For motors this is "32"</p>

<p>The third is "Command". This is a huge list of values of which only "68" and "69" are relevant. They are "Drive Motor East" and "Drive Motor West" respectively. The "Command" byte is only relevant to their specific devices specified via the "Address" byte.</p>

<p>The remaining bytes of the packet are "Data" and how they're interpreted depends on the "Command" bytes specifying a specific type of command. For motor movement there are three options. "00" makes the motor turn until a Diseqc stop command is sent. The second mode is positive values for the bytes, "01" to "7F". They represent an amount of time to turn the motor. Or by specifying negative byte values "80" to "FF" the motor is rotated a number of steps. This last is best and detailed in the <a href="/library/Space/Radio%20Astronomy/Diseqc Positioner Application Note_ EUTELSAT_ 1998.pdf">Positioner Application Note</a> (pdf) with an excerpt below,</p>

<p class="quote">The number of steps to make is given by the additional count needed to make the parameter byte reach zero (or overflow to zero if the byte is considered as unsigned). Thus the byte 'FF' (hexadecimal) requests only one step, 'FE' two steps, and for example 'F9' requests 7 steps.</p>

<p>With my motors each step corresponds to about 0.1 deg. Using this information I made up a table of Diseqc packets for each rotation direction.</p>

<pre>struct dvb_diseqc_master_cmd step_east[] =
{
	{ { 0xe0, 0x31, 0x68, 0xFF, 0x00, 0x00 }, 4 },  // Drive Motor West 1 step
	{ { 0xe0, 0x31, 0x68, 0xFE, 0x00, 0x00 }, 4 },  // Drive Motor West 2 step
	{ { 0xe0, 0x31, 0x68, 0xFD, 0x00, 0x00 }, 4 },  // Drive Motor West 3 step
	{ { 0xe0, 0x31, 0x68, 0xFC, 0x00, 0x00 }, 4 },  // Drive Motor West 4 step
	{ { 0xe0, 0x31, 0x68, 0xFB, 0x00, 0x00 }, 4 },  // Drive Motor West 5 step
	{ { 0xe0, 0x31, 0x68, 0xF6, 0x00, 0x00 }, 4 },  // Drive Motor West 10 step
	{ { 0xe0, 0x31, 0x68, 0xEC, 0x00, 0x00 }, 4 },  // Drive Motor West 20 step
	{ { 0xe0, 0x31, 0x68, 0xE2, 0x00, 0x00 }, 4 },  // Drive Motor West 30 step
	{ { 0xe0, 0x31, 0x68, 0xD8, 0x00, 0x00 }, 4 },  // Drive Motor West 40 step
	{ { 0xe0, 0x31, 0x68, 0xCE, 0x00, 0x00 }, 4 },  // Drive Motor West 50 step
	{ { 0xe0, 0x31, 0x68, 0x9C, 0x00, 0x00 }, 4 }   // Drive Motor West 100 step
};

struct dvb_diseqc_master_cmd step_west[] =
{
	{ { 0xe0, 0x31, 0x69, 0xFF, 0x00, 0x00 }, 4 },  // Drive Motor West 1 step
	{ { 0xe0, 0x31, 0x69, 0xFE, 0x00, 0x00 }, 4 },  // Drive Motor West 2 step
	{ { 0xe0, 0x31, 0x69, 0xFD, 0x00, 0x00 }, 4 },  // Drive Motor West 3 step
	{ { 0xe0, 0x31, 0x69, 0xFC, 0x00, 0x00 }, 4 },  // Drive Motor West 4 step
	{ { 0xe0, 0x31, 0x69, 0xFB, 0x00, 0x00 }, 4 },  // Drive Motor West 5 step
	{ { 0xe0, 0x31, 0x69, 0xF6, 0x00, 0x00 }, 4 },  // Drive Motor West 10 step
	{ { 0xe0, 0x31, 0x69, 0xEC, 0x00, 0x00 }, 4 },  // Drive Motor West 20 step
	{ { 0xe0, 0x31, 0x69, 0xE2, 0x00, 0x00 }, 4 },  // Drive Motor West 30 step
	{ { 0xe0, 0x31, 0x69, 0xD8, 0x00, 0x00 }, 4 },  // Drive Motor West 40 step
	{ { 0xe0, 0x31, 0x69, 0xCE, 0x00, 0x00 }, 4 },  // Drive Motor West 50 step
	{ { 0xe0, 0x31, 0x69, 0x9C, 0x00, 0x00 }, 4 }   // Drive Motor West 100 step
};</pre>

<p>For addressing specific ports of the Diseqc switch tune-s2's normal functions are used. They are called before the motor position commands are sent. Usage of the modified tune-s2 is pretty simple. The only differences are two new cli switches and not needing to give it tuning parameters.</p>

<pre>-step-east 
-step-west</pre>

They each take any value from 0 to 10 like, 

<pre>./tune-s2 -step-west 0 -committed 1</pre>

<p>This would cause the satellite dish motor on port 1 of the Diseqc switch to step 1 position counter-clockwise. To send the same command of stepping 1 position counter-clockwise to the other motor,</p>


<pre>./tune-s2 -step-west 0 -committed 2</pre>

<p>The stepping argument values 0 through 10 are mapped on a fairly arbitrary set of actual steps. This results from just doing array index look ups in the above packet tables,</p>

<pre>0->1
1->2
2->3
3->4
4->5
5->10
6->20
7->30
8->40
9->50
10->100</pre>

<pre>http://www.satnigmo.com/2254/how-to-configure-emp-centauri-diseqc-switches/</pre>

<h4>Calculating solar position and using that to decide how many steps to step per axis</h4>

<p>Figuring out where the sun is in the sky in terms of an alt-az format is made simple by <a href="http://pysolar.org/">pysolar</a>. Figuring out how to turn that position into sequences of steps on the motors is much, much harder.</p>

<pre>#! /usr/bin/env python
import Pysolar
import datetime
d = datetime.datetime.utcnow()
lat = 40.0
long = -90.0
sol_alt = Pysolar.GetAltitude(lat, long, d)
sol_long = Pysolar.GetAzimuth(lat, long, d)
print sol_alt
print sol_long</pre>


<p>These values are relative to the pysolar reference frame which is given by their diagram,</p>
<img src="http://erewhon.superkuh.com/pysolar_reference_frame.png" /><pre style="float:left;margin:1em;">$ ./solpos.py 
41.4925424732
-35.8472087363</pre>

<p>My setup is pointed directly south. So for this example time that means I need to calculate the number of steps required to turn the (top) altitude motor 41.5 <em>up</em> from level and the (bottom) azimuth motor 35.8 degrees to the <em>left</em> (east).</p>

<!--<img src="/" />-->

<!--
<pre># Frequency (MHz),Level (dB)		# Frequency (MHz),Level (dB)
54.00196,-45.6883596633			54.00196,-62.1023728582
54.0039,-45.7144431488			54.0039,-62.7271718357</pre>
</p>
-->




<hr />

<a name="pager" />
<h4>Decoding Pager Data with multimon and/or gnu radio receivers</h4>
<a href="http://erewhon.superkuh.com/gnuradio/pager_decode.png"><img src="http://erewhon.superkuh.com/gnuradio/pager_decode_sm.png" /></a>

<p>The hardest part of this is figuring out what kind of pager system you have. I spent a long time trying to decode the local FLEX pager system with decoders that did not support it.</p>

<p>Written by Thomas Sailer, HB9JNX/AE4WA, <a href="http://www.baycom.org/~tom/ham/linux/multimon.html">multimon</a> (<a href="http://www.baycom.org/~tom/ham/linux/multimon.tar.bz2">multimon.tar.bz2</a>) supports decoding a large number of pager modulations. FLEX is not one of them. Scroll <a href="#flexpager">down for FLEX</a>.</p>

<p>On June 29th 2012 <a href="http://dekar.wc3edit.net/2012/05/24/multimonng/">dekar</a> told me about his updated fork of multimon, <a href="https://github.com/EliasOenal/multimonNG.git">multimonNG</a>, with better error correction and more modulations supported. As of right this instant those on 64bit linux should just use the existing makefile and *not* qmake or qt-creator to compile it. For the windows users (or anyone wanting more info) there's a <a href="http://dekar.wc3edit.net/2012/05/24/multimonng/">precompiled version and blog post</a>. Make sure to disable all the demodulators you don't need. I think especially ZVEI is quite spammy. <a href="http://www.kb9ukd.com/digital/pocsag12.wav">This</a> and <a href="http://www.kb9ukd.com/digital/pocsag24.wav">this</a> is what pocsag sounds like if you're wondering.</p>

<p>When I originally started playing and wrote this there were only a couple options for rtlsdr receivers to use with the multimon decoder. I used patchvonbraun's multimode to save .wavs and dekar's pager example GRC I modified for OsmoSDR sources linked below for raw, real time decoding. Lately (as of late 2012/13) a large number of receivers have been released that don't depend on GNU Radio. rtl_fm is one and there's an example usage below.</p>

<h4>real time decoding rtl_fm</h4>
<pre>rtl_fm -f 930.353e6 -g 100 -s 22050 -l 310 - |multimon -t raw -a POCSAG512 -a POCSAG1200 -a POCSAG2400 -f alpha /dev/stdin</pre>

<a name="pager_realtime" />
<h4>real time decoding w/dekar's pager_fifo</h4>
<p><a href="http://dekar.wc3edit.net/2012/05/24/multimonng/">Dekar</a>'s <a href="https://github.com/EliasOenal/multimonNG.git">multimonNG</a>, a fork with improved error correction, more supported modes, and *nix/osx/windows support. In the screenshots below the signal is not pocsag. I thought it might be zwei but now I'm not so sure it's even pager data. Test samples of pocsag that Dekar links on his blog decode just fine.</p>
<img src="http://erewhon.superkuh.com/gnuradio/pager_fifo_sm.png" /><br />
<!--<a href="http://www.superkuh.com/gnuradio/pager_fifo.grc">pager_fifo.grc</a>-->
<a href="http://www.superkuh.com/gnuradio/pager_fifo_web.grc">pager_fifo_web.grc</a>

<!--<pre>mkfifo pager_fifo.raw
multimon -t raw pager_fifo.raw
gnuradio-companion pager_fifo.grc</pre>-->

<pre>mkfifo /tmp/pager_fifo.raw
./multimonNG -t raw /tmp/pager_fifo.raw
gnuradio-companion pager_fifo_web.grc</pre>

<p>In order to decode the pager data in real time you should use a first-in first-out file (fifo). Dekar's pager_fifo is designed to do that but you'll need to set the correct file paths for the File Sink yourself. In the copy downloadable here the File Sink's path is set to "/tmp/pager_fifo.raw". You should be able to run it without editing once you've made that fifo. Make sure to start multimon reading the fifo before you begin GRC and execute the receiver.</p>
<img src="http://erewhon.superkuh.com/gnuradio/pager_fifo_set.png" />

<p>In my personal copy of dekar's pager_fifo the file and audio sinks are enabled while the waterfall, wav, and other sinks are disabled. To enable the disabled (grey) block select them and press 'e' ('d to disable). The audio sink is set to pulseaudio ("pulse").</p>
<a href="http://erewhon.superkuh.com/gnuradio/dekar_pager.png"><img src="http://erewhon.superkuh.com/gnuradio/dekar_pager_sm.png" /></a>


<a name="flexpager" />
<h3>FLEX Pagers</h3>

<p>Unfortunately it turned out my local pagers were all using <a href="http://en.wikipedia.org/wiki/FLEX_%28protocol%29">FLEX</a>, and so not supported by any of the above software. But the procedures might still be useful for someone. Decoding FLEX can be done with the software PDW, but it is windows only. In GNU Radio there is additionally <a href="http://gnuradio.org/redmine/projects/gnuradio/repository/revisions/master/show/gr-pager">gr-pager</a>, which is supposed to support flex, but many implementation scripts for it are GNU Radio 3.6.5 or older and getting stuff to work with 3.7 requires namespace changes. mothran's <a href="https://github.com/mothran/flex_hackrf">flex_hackrf</a> is one of these. Since the rtlsdr receivers can but shouldn't do 3.125 MS/s, like flex_hackrf of uhd_flux, what they use natively for the bandwidth, and so decimation, and pretty much everything else have to be re-written too. I've attempted to start this and you can see <a href="/flex.py">a copy here</a>.</p>

<P>A couple days after I wrote the above paragraph zarya came on ##rtlsdr on freenode and mentioned  <a href="https://github.com/zarya/sdr/tree/master/receivers/flex">his rtlsdr supprting FLEX decoder</a> written months before. It is easy to use and works great! This script runs at a 250 KS/s sample rate and decodes 12.5 KHz channel only. Internally it uses gnuradio's optfir to generate low pass taps that wide to use witih a frequency xlating FIR filter. It then passes that to gr-pager's flex_demod. <!--In the original UHD USRP FLEX decode script a full 3.125 MHz is sampled with multiple channels decoded. This could kind of be done here by --></p>

<p><em>later</em>: argilo (Clayton Smith) has also put together an <a href="https://github.com/argilo/sdr-examples">osmosdr source based gr.pager flex decoder</a> for his GNU Radio tutorial series.</p>


<p>The below output is heavily censored and edited to avoid disclosing or reproducing sensitive information but it gives you an idea of the type of messages.</p>

<pre>git clone https://github.com/zarya/sdr
cd sdr/receivers/flex/
./rtl_flex_noX.py -f 929.56M --rx-gain=37.2
linux; GNU C++ version 4.6.3; Boost_104800; UHD_003.005.004-149-gc357a16e

No database support
gr-osmosdr v0.1.0-33-g8facbbcc (0.1.1git) gnuradio 3.7.2git-123-g0ded5889
built-in source types: file fcd rtl rtl_tcp uhd hackrf netsdr 
Using device #0 Generic RTL2832U SN: 77771111153705700
Found Rafael Micro R820T tuner
Exact sample rate is: 250000.000414 Hz

Setting gain to 20.700000 (from [0.000000, 49.600000])
Using Volk machine: avx_64_mmx_orc
0 929.560|        55|SPN|2900
0 929.560|   5555555|ALN|osoft JDBC type 4 driver for MS SQL Server 2005:FreePoolSize = 24  [03]
0 929.560|       555|ALN|MSN 020 hello Message from NOC PCB. 129       
0 929.560|   5555555|ALN| Task: 3322391 Net: 0 Pressman: REDACTED, REDACTED Click here to view the curre [28]
0 929.560| 555555555|ALN|4.Q!T .(-RS(7+*# ~A-!lu+3L:REDACTED:YSGO>T JL*qN>][WOA"$(0?"$8QB, 33*dM:YSG.>][WO<]\(0BK [1
0 929.560|   5555555|ALN|From: REDACTED@REDACTED.com Subject: REDACTED scheduled report: "05:00 Medication Devices" - Scheduled report "05:00 Medication Devices" was sent by REDACTED. <<File:05:00MedicationDevices-11-23-135-00AM.PDF>>  [43]
0 929.560|   5555555|ALN|re| 7291 W 190th St| FD o/s calling a 2nd alarm for a structure fire, Setting up water supply| REDACTED008| 05:02 . .   [97]
0 929.560|   5555555|ALN|Fr/m: 7th.Floor-.REDACTED REDACTED: +Blood Cultures; G+ cocci from yesterday's clinic draw. On Cefepime. Afebrile. New orders? Draw BCs in am? [31]
0 929.560|   5555555|SPN|766087U410 5[[[
0 929.560|   5555555|ALN|REDACTED, REDACTED 9105-2 FYI: Notified by lab stool sample came back positive of C.diff Liculda, RN REDACTED c9q [74]..</pre>


<p>I tried for over a year before successfully decoding local pager signals. Now that I have I think it is a bad idea. There is far much too much private information in cleartext. I don't plan to try again.</p>

<!--<p>In order to be compatible with modern versions of sox change line 325 in unixinput.c from,</p>
<pre>"-t", "raw", "-s", "-w", "-r", srate, "-",</pre>
<p>to,</p>
<pre>"-t", "raw", "-s", "-r", srate, "-",</pre> -->

<!--
<p>When I run it off /dev/audio something about my configuration (or lack thereof) prevents it from working. It works fine for post-processing when using patchvonbraun's GNU Radio "multimode" script to save the FM decode audio to disk as wav.</p>
<pre>./multimon -t wav pager.wav</pre>

<img src="http://erewhon.superkuh.com/gnuradio/pager_meh.png" />

<p>So far I get non-printable characters and repeated instances of "ZVEI: f" so those might be properly decoded <a href="https://en.wikipedia.org/wiki/Selcall#Tone_Sets">Selcall tone set</a>. The "f" would indicate, depending on ZVEI version either 680 Hz or 2600 Hz. Since it seemed to be ZWEI, I then used,</p>
<pre>./multimon -a ZVEI -t wav pager.wav</pre>
<p>That returns "ZWEI: f" over and over. I haven't tried decoding known good sample recordings from other people.</p>
-->

<!-- <h5>Updates</h5>
<p>I emailed the author of multimon about the "-w" switch to sox and he said "-w",</p>
<pre>>was originally meant to do. Do you remember/know?
16bit sample size. It's now -2. It should have been fixed
in http://www.baycom.org/~tom/ham/linux/multimon.html
Tom</pre>
<p>I downloaded the (new?) version and the line is,</p>
<pre>"-t", "raw", "-e", "signed", "-c", "1", "-2", "-r", srate, "-",</pre>-->

<!-- 
<h5>usrp_flex alternative...</h5>
<p>Apparently the better way to decode pager data is to use the usrp_flex program included with GNU Radio then make a flow graph with an osmosdr src right to a fifo file sink. Then run usrp_flex like,</p>
<pre>usrp_flex -F fifo -f freq</pre>
-->

<!--<hr />
<h4>Antenna</h4>
<p>More to come soon. Frequency independent antenna like, log periodic arrays, discone, and spiral best cover entire range. I want a circularly polarized antenna so I am <a href="#spiral">designing a large archimedean spiral antenna</a>.<p>-->


<hr />
<a name="gqrx" />
<h4>(old) gqrx install notes</h4>
<a href="http://erewhon.superkuh.com/gnuradio/gqrx.png"><img src="http://erewhon.superkuh.com/gnuradio/gqrx_sm.png" /></a>

<p>Read <a href="http://www.linuxwolfpack.com/RTL-SDR.php">this person's guide instead</a>.</p>

<p>When I wrote this up the <a href="http://www.oz9aec.net/index.php/gnu-radio/gqrx-sdr">original version</a> by csete didn't support the hardware yet but mathis_, phirsch, Hoernchen, and perhaps others I've missed from ##rtlsdr on freenode had added librtlsdr support to gqrx; their repos are still listed by commented out.<!--He distributed a copy, <a href="http://www-pool.math.tu-berlin.de/~mathis/gqrx.tar.bz2">www-pool.math.tu-berlin.de/~mathis/gqrx.tar.bz2</a>. But keep in mind this isn't actually a .bz2, it's a tar.gz.--> These days csete has added in rtlsdr support so you can use his original repository. </p>
<pre>
<!-- #git clone <a href="https://github.com/phirsch/gqrx">https://github.com/phirsch/gqrx</a>
# matthis is the only version I've personally tested (old)
git clone <a href="https://github.com/mathisschmieder/gqrx">https://github.com/mathisschmieder/gqrx</a>
# the original; supposed to have librtlsdr support now (new)
-->
git clone <a href="https://github.com/csete/gqrx.git">https://github.com/csete/gqrx.git</a>
cd gqrx 
# on Ubuntu, sudo apt-get install qtcreator , if you don't have it.
qtcreator gqrx.pro 	# press the build button (the hammer)
# Avoid qtcreator doing it manually.
qmake
make

./gqrx</pre>
<a name="gqrx_qtstuff" />
<h4>Use with Ubuntu 10.04 and distros with old Qt &lt; 4.7</h4>
<p>You will almost certainly not get this error. But, someone might, so I'm leaving it here to be indexed.</p>
<p>If you're like me and run an older distribution then your Qt libraries will be out of date and lack a function required for generating the name of the files to be saved when recording.</p>
<pre>/home/superkuh/app_installs/gnuradio/gqrx/gqrx/qtgui/dockaudio.cpp:100: error: currentDateTimeUtc is not a member of QDateTime</pre>
<p>Initially I thought it was a qtcreator thing so I tried to get more information by doing it manually,</p>
<p>qmake<br />
make <br />
g++ -c -pipe -O2 -I/usr/local/include/gnuradio -I/usr/local/include -I/usr/local/include -I/usr/local/include/gnuradio -D_REENTRANT -D_REENTRANT -I/usr/include/libusb-1.0 -Wall -W -D_REENTRANT -DQT_NO_DEBUG -DQT_NO_DEBUG_OUTPUT -DVERSION="\"0.0\"" -DQT_NO_DEBUG 
-DQT_GUI_LIB -DQT_CORE_LIB -DQT_SHARED -I/usr/share/qt4/mkspecs/linux-g++ -I. -I/usr/include/qt4/QtCore -I/usr/include/qt4/QtGui -I/usr/include/qt4 -I. -I. -o dockaudio.o qtgui/dockaudio.cpp<br />
qtgui/dockaudio.cpp: In member function void DockAudio::on_audioRecButton_clicked(bool):<br />
qtgui/dockaudio.cpp:100: error: currentDateTimeUtc is not a member of QDateTime<br />
<br />
make: *** [dockaudio.o] Error 1</p>
<p>To get it to compile on these systems you'll have to do the below. (edit: This little change is now <a href="https://github.com/phirsch/gqrx/commit/060fe8f693f91e5b5de7541fac45ae6d7d02ce5f">added into phirsch's</a>.)</p>
<p>Ubuntu 10.04 has old Qt libs and gqrx uses a function call not in them. So, while I was waiting for Qt 4.74 to compile I decided to try a hack. I removed that function call with a static string of text. [edit] I later found comparable functions for Qt 4.6 and older.</p>
<p>If you are using qtcreator like the docs suggest you can double click on the error and go to the line. If not, it was in ./Sources/qtgui/dockaudio.cpp replace,</p>
<pre>
void DockAudio::on_audioRecButton_clicked(bool checked)
{
    if (checked) {
        // FIXME: option to use local time
        lastAudio = QDateTime::currentDateTimeUtc().toString("gqrx-yyyyMMdd-hhmmss.'wav'");

</pre>
<p>With something like this.</p>
<pre>
void DockAudio::on_audioRecButton_clicked(bool checked)
{
    if (checked) {
        // FIXME: option to use local time
        // use functions compatible with older versions of Qt.
        lastAudio = QDateTime::currentDateTime().toUTC().toString("gqrx-yyyyMMdd-hhmmss.'wav'");

</pre>
<p>And it'll compile and run correctly on my specific machine. <a href=""> </a></p>

<hr />
<a name="ltescanner" />
<h4>Compiling <a href="https://github.com/Evrytania/LTE-Cell-Scanner">LTE Cell Scanner</a> and <a href="http://www.evrytania.com/lte-tools/lte-tracker">LTE Tracker</a> on Ubuntu 10.04</h4>
<p>Before starting make sure to have a fortran compiler, FFTW, BLAS, and LAPACK libraries installed from the repositories.</p>
<pre>sudo apt-get install automake autoconf libtool libfftw3-3 libfftw3-dev gfortran libblas3gf libblas-dev liblapack3gf liblapack-dev libatlas-base-dev</pre>
<p>If you're using 12.04 just follow the <a href="https://github.com/Evrytania/LTE-Cell-Scanner">instructions on the github page</a> and everything is trivial. For 10.04 (lucid) users the the initial hurdle is cmake. LTE Cell Scanner requires cmake 2.8.8 and Ubuntu 10.04 only has 2.8 the finding of BLAS and LAPACK libraries will fail like,</p>
<pre>CMake Error at CMakeLists.txt:1 (CMAKE_MINIMUM_REQUIRED):
  CMake 2.8.4 or higher is required.  You are running version 2.8.0.</pre>
<p>Until you open CMakeList.txt and change the version number on first line to 2.8.0. After fixing that the BLAS and LAPACK issues come in,</p>
<pre>cmake ..
-- Found ITPP: /usr/lib64/libitpp.so
CMake Error at /usr/share/cmake-2.8/Modules/FindBLAS.cmake:45 (message):
  FindBLAS is Fortran-only so Fortran must be enabled.
Call Stack (most recent call first):
  CMakeLists.txt:29 (FIND_PACKAGE)</pre>
<p>You can see my <a href="http://superkuh.com/lte-scanner.txt">installation notes</a> before I figured it out. To fix it I searched for people complaining of <a href="http://public.kitware.com/Bug/view.php?id=9976">similar problems on other projects</a> and then replaced my *system* files with theirs, <a href="http://public.kitware.com/Bug/file_download.php?file_id=3380&type=bug">FindBLAS.cmake</a>.</p>
<pre>sudo cp /usr/share/cmake-2.8/Modules/FindBLAS.cmake /usr/share/cmake-2.8/Modules/FindBLAS.cmake.bak 
sudo cp FindBLAS.cmake /usr/share/cmake-2.8/Modules/</pre>
<p>LAPACK will also fail this way. I used this arbitray cmake file, <a href="http://code.google.com/p/qmcpack/source/browse/trunk/CMake/FindLapack.cmake?r=5383">http://code.google.com/p/qmcpack/source/browse/trunk/CMake/FindLapack.cmake?r=5383</a>. And <a href="/gnuradio/FindLapack.cmake">this</a> is a local backup in case that disappears.</p>
<pre>sudo cp /usr/share/cmake-2.8/Modules/FindLAPACK.cmake /usr/share/cmake-2.8/Modules/FindLAPACK.cmake.bak
sudo FindLAPACK.cmake /usr/share/cmake-2.8/Modules/FindLAPACK.cmake</pre>
<p>After fixing the cmake issues compile and install the latest <a href="http://itpp.sourceforge.net/current/index.html">IT++</a> (ITPP 4.2). Make sure to completely remove the old ITPP 4.0.7 libraries from the Ubuntu repository. When LTE Cell scanner compiles you can go back and restore the .bak cmake files. The rate of scan is about 0.1 Mhz per 10 seconds.</p>
<pre>./CellSearch -v -s 751e6 -e 751e6
LTE CellSearch v0.1.0 (release) beginning
  Search frequency: <a href="http://niviuk.free.fr/lte_band.php">751 MHz</a>
  PPM: 100
  correction: 1
Found Elonics E4000 tuner
Waiting for AGC to converge...
Examining center frequency 751 MHz ...
Capturing live data
  Calculating PSS correlations
  Searching for and examining correlation peaks...
  Detected a cell!
    cell ID: 414
    RX power level: -17.0733 dB
    residual frequency offset: 43592.8 Hz
  Detected a cell!
    cell ID: 415
    RX power level: -20.8041 dB
    residual frequency offset: 43592.3 Hz
  Detected a cell!
    cell ID: 209
    RX power level: -28.8524 dB
    residual frequency offset: 43581.2 Hz
Detected the following cells:
C: CP type ; P: PHICH duration ; PR: PHICH resource type
CID      fc   foff RXPWR C nRB P  PR CrystalCorrectionFactor
414    751M  43.6k -17.1 N  50 N one 1.0000580496943698439
415    751M  43.6k -20.8 N  50 N one 1.0000580490797574829
209    751M  43.6k -28.9 N  50 N one 1.0000580342133056355
</pre>
<p>Both positive and negative frequency offsets happen, but rarely in the same dongle.</p>

<p>LTE Tracker I haven't used as much yet (recently <a href="http://www.reddit.com/r/RTLSDR/comments/13dxve/lte_tracker/">released</a>) but it is included in the github repository cloned initially and should be compiled as well if you did the above. Check out the authors site for <a href="http://www.evrytania.com/lte-tools/lte-tracker">videos</a> of it's use since an ascii paste of the ncurses like interface wouldn't tell you much. But... the start looks like this,</p>

<pre>./LTE-Tracker -f 751e6
LTE Tracker v1.0.0 (release) beginning
  Search frequency: 751 MHz
  PPM: 120
  correction: 1
Found Rafael Micro R820T tuner
Calibrating local oscillator.
Calibration succeeded!
   Residual frequency offset: -48937.5 Hz
   New correction factor: 0.99993484110674779597
Searcher process has been launched.</pre>

<hr />
<a name="grc">
<h4>Slightly altered GNU Radio Companion flowcharts</h4>
<p class="quote">"The GUI stuff in Gnu Radio was rather an afterthought. Nobody really expected that you'd use it to build actual applications, but rather just use it as a way of making "test jigs" for your signal flows."</p>
<p>This section is my notes on how I made basic examples work, and how I edited those examples in very simple and often broken ways. Also, since gqrx, multimode, and other intergrated receivers came out I don't see any need to update these as things change. <b>Most of this is very old.</b></p>
<p>While there are links to the originals in the summaries, these descriptions are of the versions modified by me; usually just sample rate and GUI stuff. While the sample rate or tuner width I set may be some large number, it'll become obvious what the limits of each other as you scan about and see the signal folding or mirroring. <b>Using sample rates above 2.4 MS/s with rtlsdr is not recommended. It *does* create aliases all over.</b> If you're using GNU Radio 3.7 don't even bother trying with any .grc files hosted here.</p>

	<li>FM:<ul>
		<li><a href="#patchvonbraun">patchvonbraun's simple (stereo) fm receiver</a> - harder setup, best reception, best sound, 2.048 MS/s, +-600Khz fine tune</li>
		<li><a href="#lindi">lindi's fm receiver</a> easy setup, good reception, good sound, 3.2 MS/s, +-600Khz fine tune</li>

		<li><a href="#superkuh">superkuh's offset fm receiver</a> - easy setup, okay reception, okay sound, 2.8 MS/s, +-900Khz tune, +-50Khz fine.</li>
<!--		<li><a href="#richg">richg's fm (mono) receiver</a> - easy setup, good reception, good sound, 1.44 MS/s, no fine tune</li> -->
		<li><a href="#simple">2h20's beginner fm (mono) receiver</a> - easy to understand, easy setup, okay sound, 2.8 MS/s, no fine tune</li>
		</ul>
	</li>
	<li>SSB:<ul>
		<li><a href="#ssb">OZ9AEC's SSB Receiver</a> - SSB rx and record to disk, seperate playback script. 1 MS/s, +-1k fine tune.</li>
		</ul>
	</li>

</ul>
<h4>Tips</h4>
<p>If it comes with a python file, try that first before generating one from the GRC file. When tuning, make sure to hit enter again if it doesn't work the first time or tunes to the wrong frequency. Always hit autoscale to start, and for FFT displays try using the "average" settings. I have set all audio sinks to "pulse" (pulseaudio) instead of say, "hw:0,0" (ALSA). You might have to change that. To get a list of hardwareuse "aplay -l". That'll show the various cards and devices. Use the format, "hw:X,Y" where "hw:CARD=X,DEV=Y". Some flowcharts have variables for it, others put it directly in the Audio Sink element. If you hear something interesting you can try comparing it to indentified samples from <a href="http://www.kb9ukd.com/digital/">http://www.kb9ukd.com/digital/</a> or <a href="http://hfradio.org.uk/html/digital_modes.html">http://hfradio.org.uk/html/digital_modes.html</a>. or the windows program, <a href="http://signals.radioscanner.ru/info/item21/">Signals Analyzer</a>. Check <a href="http://www.radioreference.com/">http://www.radioreference.com/</a> or <a href="http://wireless2.fcc.gov/UlsApp/UlsSearch/searchAdvanced.jsp">http://wireless2.fcc.gov/UlsApp/UlsSearch/searchAdvanced.jsp</a> to see what's in the USA area at a given frequency.</p>
<h5>Multiple Dongles</h5>
<p>There are two ways to specify the use of multiple dongles. The first, correct, way is to set the "Num Channels" in the OsmoSDR Source block to "2" and then specify the device IDs in "Device Arguments" like, "rtl=0 rtl=1". Each specified device is seperate with a space from the previous one.</p>
<p>The not so correct but still working way is to use multiple OsmoSDR Source blocks with "Num Channels" set to "1" and each with it's respective "Device Arguments" field set to "rtl=0" or "rtl=1", or so on.</p>
<p>The OsmoSDR Source block has extensive help files at the bottom of it's properties if you scroll down.</p>
<h5>Editing</h5>
<p>To enable a block, select it and press 'e'. To disable a block select it and press 'd'. When disabled blocks will appear darker gray.</p>
<p>If you open a .grc file and it looks like there are blocks missing (red error highlights and no connections between them) then it is likely the name of the block changed during some GNU Radio update. If your install is more than a month or two old this often happens. Update GNU Radio.</p> 
<p>It's easier to type in 1e6 than 1000000 so use scientific notation when you can in variable fields. If you double click on an element in a flowchart it usually includes a helpful "Documentation:" of most the variables to be set at the bottom. The GUI element grid position is a set of two pairs of numbers: "y,x,a,b" where the first pair "y,x," is position (y row, x column) and "a,b" is the span of the box. If you enter a Grid Position and it overlaps with another element it'll turn red and report the error and where the origin is of the element it overlaps with.</p>
<pre>Use the Grid Position (row, column, row span, column span) to position the graphical element in the window.</pre> 
<p>The tab effect is done with notebooks.</p>
<a href="http://erewhon.superkuh.com/gnuradio/grc_gui.png"><img src="http://erewhon.superkuh.com/gnuradio/grc_gui_sm.png" /></a>
<p>For RTL2832 Source the minimum sample rate is ~800KS/s, it's gr-baz(?) and generally not updated. Use OsmoSDR source. It's under "OsmoSDR", not "Sources" on the right panel). It has a 1MS/s minimum sample rate. It's not recommended to use sample rates above 2.4M.</p>
<p>In older versions of gr-osmosdr and rtl-sdr I think automagic gain control (AGC) was on all the time so you didn't have to set the gain explicitly in the source in GRC. New versions require that and also require setting the chan 0. freq to something. <p>The dongles seem to have noise at their 0Hz center frequency so the best performance is from selecting a band 100-200Khz offset from the center (depending on signal type). patchvonbraun's <a href="#patchvonbraun">simple_fm_rcv</a> is a great example of that.</p>

<hr />
<a name="patchvonbraun">
<h4>patchvonbraun's simple_fm_rcv</h4>
<p></p>
<p>(this summary is outdated) The best sounding software I've found for listening to FM is patchvonbraun's <a href="https://www.cgran.org/browser/projects/simple_fm_rcv/trunk">Simple FM (Stereo) Receiver</a>. I don't think it is very simple; it includes many advanced FM specific features like extraction of the 19k (pilot) tone next to some commercial FM broadcasts. It used to do RDS, I hear, and older versions checked into CGRAN still have it, but it is removed for simplicitly in this version.</p>
<!--<p>One of these I just edited the GUI to be more friendly, and the other I increased the sample rate while also increasing the Frequency Xlating FIR filter decimation and the offset compensation for other bits. With the waterfall before the filter it shows a large swatch of spectrum, and the result sounds close normal; more noise obviously. The reception band is wider than normal so that's also useful for searching. If you tuned to a signal and aren't hearing anything then look at the RF Power and adjust the Mute Level accordingly.</p>-->
<pre>svn co https://www.cgran.org/svn/projects/simple_fm_rcv
cd simple_fm_rcv/
cd trunk
less README
make
make install
## it'll install to ~/bin/, so I use ~/superkuh/bin below
set PYTHONPATH=/usr/local/lib/python2.6/dist-packages:/home/superkuh/bin
# run the python script
python simple_fm_rcv.py
# or edit it
gnuradio-companion simple_fm_rcv.grc</pre>

<!--
<p>The edits I made are old and outdated. Ignore them. So far I can't get the newer OsmoSDR source block to work with this.</p>
<p>1.024 MS/s or 2.048 MS/s field of view, +-500Khz fine tuning.</p>
<ul>
<li><a href="/simple_fm_rcv_edit.grc">Modified patchvonbraun's simple_fm_rcv</a> (.grc, GUI only, same sample rate, <a href="#simplefmrcv_edit_1">screenshots</a>)</li>
<li><a href="/simple_fm_rcv_edit_wider.grc">Modified sample rate patchvonbraun's simple_fm_rcv</a> (.grc, slightly more noise, more spectrum visible, <a href="#simplefmrcv_edit_2">screenshots</a>)</li>
</ul>


<a href="http://www.superkuh.com/gnuradio/simple_fm_rcv_pulse6.grc.png"><img src="http://www.superkuh.com/gnuradio/simple_fm_rcv_pulse6.grc_sm.png" /></a><br /> 
-->
<!-- <a href="/smplfm_grc.png"><img src="smplfm_grc_sm.png" /></a><br /> -->
<!--
<a name="simplefmrcv_edit_1">
<p>Showing the GUI only modifications with no change in sample rate.</p>
<a href="http://www.superkuh.com/gnuradio/smplfm_03_2.png"><img src="http://www.superkuh.com/gnuradio/smplfm_03_2_sm.png" /></a><br />
<a href="http://www.superkuh.com/gnuradio/smplfm_04_2.png"><img src="http://www.superkuh.com/gnuradio/smplfm_04_2_sm.png" /></a><br />

<a name="simplefmrcv_edit_2">
<p>Showing the GUI, sample rate and decimation, extra tuning options, and offset compensation for those changes.</p>
<a href="http://www.superkuh.com/gnuradio/example.png"><img src="http://www.superkuh.com/gnuradio/example_sm.png" /></a><br />
<p>Older screenshots of the sample rate, and decimation and offset compensation.</p>
<a href="http://www.superkuh.com/gnuradio/smplfm_01.png"><img src="http://www.superkuh.com/gnuradio/smplfm_01_sm.png" /></a><br />
<a href="http://www.superkuh.com/gnuradio/smplfm_02.png"><img src="http://www.superkuh.com/gnuradio/smplfm_02_sm.png" /></a><br /> 
<a href="http://www.superkuh.com/gnuradio/smplfm_03.png"><img src="http://www.superkuh.com/gnuradio/smplfm_03_sm.png" /></a><br /> 
<a href="http://www.superkuh.com/gnuradio/smplfm_04.png"><img src="http://www.superkuh.com/gnuradio/smplfm_04_sm.png" /></a><br />
-->
<hr />

<a name="lindi">
<h4>lindi's FM receiver</h4>
<p>Original: <a href="http://lindi.iki.fi/lindi/gnuradio/rtl2832-cfile-lindi-fm.grc">http://lindi.iki.fi/lindi/gnuradio/rtl2832-cfile-lindi-fm.grc</a> , this was an example posted to ##rtlsdr by lindi. It used a file source which was decoded to wav and saved to disk. Seen in the screenshot above.</p>
<a href="http://erewhon.superkuh.com/gnuradio/rtl2832-cfile-lindi-fm.png"><img src="http://erewhon.superkuh.com/gnuradio/rtl2832-cfile-lindi-fm_sm.png" /></a>
<p>Modified: <a href="http://superkuh.com/rtl2832-cfile-lindi-fm_edit.grc">http://superkuh.com/rtl2832-cfile-lindi-fm_edit.grc</a> , had a frontend GUI and an increased sample rate. Right now the rate of the audio files saved out is... not very useful. But it sounds fine. Seen below.</p>
<p>3.2 MS/s field of view, tune +-900Khz</p>
<a href="http://erewhon.superkuh.com/gnuradio/rtl2832-cfile-lindi-fm_offset.grc.png"><img src="http://erewhon.superkuh.com/gnuradio/rtl2832-cfile-lindi-fm_offset.grc_sm.png" /></a><br />
<a href="http://erewhon.superkuh.com/gnuradio/lindi_fm_01.png"><img src="http://erewhon.superkuh.com/gnuradio/lindi_fm_01.png" /></a><br />
<a href="http://erewhon.superkuh.com/gnuradio/lindi_fm_02.png"><img src="http://erewhon.superkuh.com/gnuradio/lindi_fm_02.png" /></a><br />
<a href="http://erewhon.superkuh.com/gnuradio/lindi_fm_03.png"><img src="http://erewhon.superkuh.com/gnuradio/lindi_fm_03.png" /></a><br />



<!-- <hr />
<a name="richg">
<h4>RichG's FM Receiver</h4>
<p>1.4 MS/s field of view, no fine tuning.</p>
<p>RichG's mono FM receiver was a great example to learn from. I think he posted it to pastebin. The audio is very clear and without any pops or static. It works without tuner crashes too. The frequency control is not so fine and the audio is not perfect, but it is useful for scanning. It is unique in allowing for uncompensated adjustment of the sample rate. Frequency is entered as 887 = 88.7Mhz, or 1062 = 106.2Mhz; The screenshots below show when the slider was  extended to the entire frequency range; I set it back to the normal FM range but left it at 1000 steps. I changed the FM Deemphasis sample rate from "samp_rate/10" to "samp_rate/30" so the output would be 48Khz instead of 144Khz. It is best to put small adjustments in the text box. The sample rate, and displayed bandwidth are pretty low. But if you only use it for commercial FM, what it is for, then it is great. I modified the frequency range and organized the displays a little bit. There aren't any dependencies other than the typical for a GNU radio rtlsdr setup.</p>
<ul>
<li><a href="/richg_edit.grc">Modified RichG's Mono FM Receiver</a> (.grc)</li>
</ul>
<a href="/smplfm_05.png"><img src="smplfm_05_sm.png" /></a><br /> 
<a href="/richg_grc.png"><img src="richg_grc_sm.png" /></a><br /> 
-->

<hr />
<a name="simple">
<!-- <a href="/smplfm_06.png"><img src="smplfm_06_sm.png" /></a><br /> -->
<h4>2h20's simple fm receiver</h4>
<p>2.8 MS/s field of view, no fine tuning.</p>
<p>2h20 <a href="http://2h2o.tumblr.com/">made available</a>, with thorough explaination, a bare bones FM (mono) receiver to learn how to use GNU Radio. This was the first one I managed to get to work. Because the original h202's uses the RTL2832 Source and not the OsmoSDR Source you might experience tuner crashes if you scan too quickly. Make sure to un/replug in the dongle after these. It's best just to enter the frequency as a number.</p>

<p>[Be aware this section of this page was written many months ago when rtl-sdr was different and I had little idea of what I was doing. xzero has since <a href="http://ubuntuforums.org/showthread.php?t=2054073">manually added signal seeking to this example</a>.]</p>

<p>My edit of 2h20's simple receiver does not add much, but I did replace the RTL2832 source with an OsmoSDR source to avoid tuner crashes. I also increased the sample rate to 2.8MS/s (to see more spectrum) and then increased the decimation in the filter from 4 to 8 to compensate so everything still decodes/sounds right. I also remove the superfluous throttle block.<!-- I did not fix the problem with the WBFM block being told it's receiving one sample rate but being sent another (WBFM channels are 200Khz wide, NBFM demodulator ~15Khz)--></p>

<ul>
<li><a href="/simplest.grc">Modified 2h20's Mono FM Receiver</a> (.grc)</li>
</ul>

<a href="http://erewhon.superkuh.com/gnuradio/2h2o.png"><img src="http://erewhon.superkuh.com/gnuradio/2h2o_sm.png" /></a><br />
<a href="http://erewhon.superkuh.com/gnuradio/simplest_fm_gui.png"><img src="http://erewhon.superkuh.com/gnuradio/simplest_fm_gui.png" /></a><br />
<hr />
<a name="superkuh">
<a name="crossed">
<h4>my offset tuning + recording example</h4>
<p>2.8 MS/s field of view, +-900Khz tuning, +-50Khz fine.</p>
<p>This takes parts from a bunch of the other example receivers and repurposes them in presumably incorrect but seemingly working ways. It is a basic example of how to offset the tuner 200khz away from the center to avoid the noise there. I started with 2h20's simple tuner's GUI framework and removed almost all of the content. I copied, with inaccurate trial and error changes of sample rate and filter offset, sections of the offset tuning and other advanced bits from simple_fm_rcv and <a href="https://github.com/csete/gnuradio-grc-examples/blob/master/receiver/wfm_rx.grc">wfm_rx.grc</a>. The tuner is tuned +200Khz. The freq_xlating filter is tuned +200Khz. The the bandpass filter is specified in a variable,</p>
<pre>firdes.complex_band_pass(1.0,1.024e6,-95e3,95e3,45e3,firdes.WIN_HAMMING,6.76)</pre>
<p>The net result is that the frequency of interest comes out of the tuner 200Khz below DC, and the freq_xlater "lifts it up" by 200Khz, and then it's bandpassed.</p> 
<img style=float:left;margin:1em;" src="http://erewhon.superkuh.com/gnuradio/freq_offset.png" />
<p>I also blindly copied the RF power display, a toggle for saving the audio files out to disk, and a +-900khz tuning slider from other receivers. I added a second 'fine' tune +-50Khz. This is done by setting the frequency of the Xlating FIR filter to,</p>
<pre>freq_offset+fine+finer</pre>
<p>where freq_offset is the frequency offset from center (200Khz in this case), fine is the ID of a wx gui slider for regular tuning, and finer is the same for fine tuning. In order for the frequency display to show the proper value it was correspondingly set to a variable ID cur_freq,</p>
<pre>frequency-fine-finer</pre>
<img src="http://erewhon.superkuh.com/gnuradio/tuning.png" /> 
<p>I also made the current frequency display a editable text field so you can tune, copy, and paste. There are good examples of how notebook positioning works and includes simple scripting examples for the file field. This flowchart is simple enough to learn from but includes many elements pulled out of the very complex <a href="#patchvonbraun">simple_fm_rcv</a> from patchvonbraun. Without his explanation of the offset process I wouldn't have figured it out. All blocks are layed out by type and GUI elements in the same order as they appear when run. This should help you figure out Grid and Notebook positioning.</p>
<p>The sound is only "okay". I think the signal is being clipped off at the edges a little bit. I am not sure if it is required to install patchvonbraun's simple_fm_rcv to use this, I do use some of his custom filter stuff.</p>
<h4>Usage</h4>
<p><!--First, you'll probably need to <a href="#patchvonbraun">install patchvonbraun's simple_fm_recv</a> because I use bits of it. But maybe not. If you try, tell me.--> Use the Waterfall for scanning through channels. Once located, look at the offset from 0 on the bottom display. Use that to set the tuning (and fine) slider and wiggle it till you get the signal crossing the band in the "Second Filter" top display. Switch to FFT view and look at the bottom "First Filter" display, use tuning and fine tuning to center the peak on the "First Filter" display. Or the other way around. It's personal preference. Ignore the noise you see at higher frequencies (900Mhz) at +0.2Mhz baseband. Although sometimes it gets folded in depending on tuning.</p>
<ul>
<li><a href="/simplest_2.grc">superkuh's FM w/offset tuning, fine tuning, and recording</a> (.grc)</li>
</ul>
<a href="http://erewhon.superkuh.com/gnuradio/test.png"><img src="http://erewhon.superkuh.com/gnuradio/test_sm.png" /></a><br />
<!-- <a href="/superkuh_fm_grc.png"><img src="/superkuh_fm_grc_sm.png" /></a><br /> -->
<!--<a href="/superkuh_fm_1.png"><img src="/superkuh_fm_1.png" /></a><br /> -->
<a href="http://erewhon.superkuh.com/gnuradio/superkuh_fm_1_2.png"><img src="http://erewhon.superkuh.com/gnuradio/superkuh_fm_1_2.png" /></a><br />
<a href="http://erewhon.superkuh.com/gnuradio/superkuh_fm_2.png"><img src="http://erewhon.superkuh.com/gnuradio/superkuh_fm_2.png" /></a><br />
<a href="http://erewhon.superkuh.com/gnuradio/superkuh_fm_3.png"><img src="http://erewhon.superkuh.com/gnuradio/superkuh_fm_3.png" /></a><br />


<!-- <hr />
<a href="https://github.com/csete/gnuradio-grc-examples/blob/master/receiver/wfm_rx.grc">wfm_rx.grc</a> -->
<hr />
<a name="ssb">
<h4>SSB Receiver and data Recorder</h4> 
<p>Created by <a href="http://www.oz9aec.net/index.php">Alexandru Csete OZ9AEC</a> the notes say, "Simple SSB receiver prototype". This comes from the GNU Radio GRC examples repository over at <a href="https://github.com/csete/gnuradio-grc-examples/tree/master/receiver">https://github.com/csete/gnuradio-grc-examples/tree/master/receiver</a></p>
<pre>git clone https://github.com/csete/gnuradio-grc-examples.git</pre>
<p>I changed the way it saves samples for the sister decoder program by adding automatic generation of file names and an on/off tickbox toggle for recording. You might want to change the default directory by editing the variable "prefix". The key was</p>
<pre>"/dev/null" if record == False else capture_file</pre>
<p>in the File Sink 'file' field. I also changed the GUI so it was easier to find signals. Use the saved .bin files with ssb_rx_play to hear. Jumping around in frequency is a lot smoother when reading from disk instead of the dongle.</p> 
<ul>
<li><a href="/ssb_rx_rec_edit.grc">Modified OZ9AEC SSB Receiver</a> (.grc)</li>
<li><a href="https://github.com/csete/gnuradio-grc-examples/blob/master/receiver/ssb_rx_play.grc">ssb_rx_play</a> (.grc)</li>
</ul>
<a href="http://erewhon.superkuh.com/gnuradio/ssb_rcv.png"><img src="http://erewhon.superkuh.com/gnuradio/ssb_rcv_sm.png" /></a><br />
<a href="http://erewhon.superkuh.com/gnuradio/ssb_play.png"><img src="http://erewhon.superkuh.com/gnuradio/ssb_play_sm.png" /></a><br />
<a href="http://erewhon.superkuh.com/gnuradio/ssb_rcv_grc.png"><img src="http://erewhon.superkuh.com/gnuradio/ssb_rcv_grc_sm.png" /></a><br />

<!--
<hr /><pre>
git clone https://github.com/dbasden/python-librtlsdr.git
cd python-librtlsdr/
./sweep.py test.log

Found Elonics E4000 tuner
Using ezcap USB 2.0 DVB-T/DAB/FM dongle
50.0 MHz 50.5 MHz 51.0 MHz 51.5 MHz 52.0 ...
... 998.0 MHz 998.5 MHz 999.0 MHz 999.5 MHz

ls -lathr
total 1.4G
drwxr-xr-x 3 superkuh superkuh 4.0K 2012-05-04 01:11 ..
-rwxr-xr-x 1 superkuh superkuh  624 2012-05-04 01:11 sweep.py
-rw-r--r-- 1 superkuh superkuh  454 2012-05-04 01:11 README
drwxr-xr-x 8 superkuh superkuh 4.0K 2012-05-04 01:11 .git
-rwxr-xr-x 1 superkuh superkuh  707 2012-05-04 01:11 example.py
drwxr-xr-x 2 superkuh superkuh 4.0K 2012-05-04 01:12 rtlsdr
drwxr-xr-x 4 superkuh superkuh 4.0K 2012-05-04 01:12 .
-rw-r--r-- 1 superkuh superkuh 1.4G 2012-05-04 01:28 test.log
-rw-r--r-- 1 superkuh superkuh 1.4G 2012-05-04 01:30 test2.log
</pre>
-->

<!--
<hr />
<h3>rtlsdr analog interferometry?</h3>

<p>I think I was going about this the wrong way. To do inteferometry with the dongles all the phase stuff has to be done way before the dongle gets involved. So here are my notes on a possible 10 Ghz interferometer using two horn antenna 60cm (20 wavelengths) apart connected with 30cm lengths of RG6, a 90 degree combiner for ~8-12 Ghz, a single very cheap ($10) satellite LNB, and an rtlsdr dongle.</p>

<p>Take apart the cheap 10 Ghz LNB. Remove the feed. Connect the LNB input that used to connect to the feed to a 0 Degree combiner @ 10 Ghz. The two inputs on the combiner go to 0.3 meter lengths of RG6 coaxial cable. The coax hook directly to monopole feeds two pyramidal horn antenna made from aluminized foam.</p>

<pre>10 Ghz [2 horn antenna -&gt; 2 RG6 coax cables of 10 wavelengths @ 10 Ghz (30cm) -&gt; 0 degree coupler -&gt; satellite LNB downconverter]-&gt; 1.4 Ghz -&gt; [ rtlsdr dongle ] -&gt; simple_ra

57.3  (3cm wave)/(1 meter dish) = 1.719 degree 3dB beamwidth

Waveguide params: http://www.microwavers.org/waveguide.htm
WG16,EIA-WR90,IEC-R100:	Fc1,6.557 GHz - Flo,8.20 - GHz Fhi,12.4 GHz -  Fc2,13.114 GHz
Internal Width  22.860 mm / 0.900 inches
Internal Height 10.160 mm / 0.400 inches</pre>

<p>I thought about putting two 10 Ghz preamplifiers directly on the antenna. This then became a bad idea for a couple of reasons. First because of the cost of the parts, or the difficulty in tapping off the signal before downconversion when using modified sat LNB. And second due to any two identical pre-amplifiers not actually being identical. They would introduce more phase noise before the 0 degree combiner.</p>	

<pre>&lt;superkuh&gt; Would putting a two preamplifiers of the same type directly on the antenna feeds of a 2 element interferometer before a 0 degree combiner destroy the phase information?
&lt;arick&gt; superkuh: No, it would change the phase, possibly nonlinearly, but you can recover the original phase
&lt;jarick&gt; (Also, "same type" is very tricky)
&lt;jarick&gt; superkuh: I have a similar thing, I compensate for phase shift in software
&lt;superkuh&gt; Does that requires a receiver after the combiner that has very low phase noise?
&lt;jarick&gt; superkuh: Nope.
&lt;jarick&gt; superkuh: All you do is sample, stick a reference generator exactly in the centre of the two antennas and compensate
&lt;jarick&gt; The idea is to take out all differences in phase
&lt;jarick&gt; (Compensation is nonlinear btw)</pre>

<p>So no pre-amplifiers. The sun's brightness temperature at 10 Ghz for a 0.5 degree beamwidth is 10000 K. But a horn's beamwidth will be more like 20 degrees and so it'll be much lower.</p>


<p class="quote">Measurements show that the power flux density at 8.8 GHz (3.4 cm) is higher than that at 2.8 GHz (10.7 cm) by a factor of about 2.17 on average. As a result, the brightness temperature at 8.8 GHz is about 22 percent that at 2.8 GHz because of the smaller wavelength.</p>

<p class="quote">The basis of the boom is east-west oriented, what means that the antennas lie in the meridian plane of the mean transit of the sun. The elevation of the antennas corresponds to the mean declination of the sun. This elevation must be adjusted manually twice a month.</p>

-->
<!--
<hr />
<h4>Clocks, distributing clocks to other dongles, and the impossible goal of digital correlator inteferometry with dongles</h4>
<p>When following the fringes.org simple interferometer guide I sampled and amplified (and attenuated) the clock from one receiver to another. I was thinking it might be possible with the dongles. The datasheets for the tuners suggest so but there's no information on the RTL2832U chips clock system.</p>
<p>Even if the dongles tuners' share a clock (16Mhz), and all the RTL2832U's shared their different distributed clock (28.8Mhz), the samples with no metadata would be jittered in time. Additionally supplying anything but 28.8Mhz to the realtek chip would mess up USB and quality 28.8Mhz crystals are only available in huge lots. Theoretically some external well timed pulse introduced to the signal could be used to align the samples.... but that's getting more complex than I can hope to tackle.</p>
<p>Distributing clocks might still be useful even interferometry isn't possible. It's simpler to start with direct sampling mode because then only the RTL2832U's clocks would have to be synchronized and tuners could be ignored. This leads to questions. Just what type of signal, beyond the frequency, does the RTL chip expect? Triangle wave? What voltage? etc. This will require physical diagnostics.</p>
<p>Regardless, here's a mock-up GNU Radio Companion flowchart of how correlation of two rtlsdr sources might be done: <a href="http://superkuh.com/interferometer_rtlsdr.grc">interferometer_rtlsdr.grc</a></p>

<h3>Interferometry with dongles? Maybe...</h3>
<p>It probably isn't possible to do interferometry with the data from multiple rtlsdr dongles with free running oscillators. It probably isn't even possible to do interferometry with the data from multiple rtlsdr dongles with shared distributed 28.8 MHz clocks for just the RTL2832's in direct sample mode using just one ADC pair. Even if all the RTL2832U's shared a distributed clock the debug mode samples with no metadata would be jittered in time by the USB protocol. Theoretically some external well timed pulse introduced to the signal could be used to align the samples.... but that's getting more complex than I can hope to tackle.</p>
<p>So it probably isn't possible to do interferometry with rtlsdr dongles in computer post processing. But that doesn't mean you can't use them as a receiver <em>after</em> an analog correlator in the form of a simple power combiner. 

-->

<a name="odroid">
<hr />
<h5>How to use rtlsdr and hackrf on a *fresh* odroid-u3 with ubuntu</h5>
<pre># rtlsdr on odroid-u3
sudo /usr/local/bin/root-utility.sh # resize partition first
sudo apt-get update
sudo apt-get upgrade
sudo apt-get -f dist-upgrade
# at this point you'll get a kernel that won't work with lots of modules (like NFS)
# use root-utility.sh again to update the kernel and it'll work.
sudo /usr/local/bin/root-utility.sh
# Install the required programs and libs
sudo apt-get install git cmake libusb-1.0-0 libusb-1.0-0-dev
# For some reason libusb.h didn't get installed so I did it manually
sudo apt-get install unp # to unpack the .deb
apt-get download libusb-1.0-0-dev
unp data.tar.xz
unp libusb-1.0-0-dev_2%3a1.0.17-1ubuntu2_armhf.deb
sudo cp ./usr/include/libusb-1.0/libusb.h /usr/include/libusb-1.0/libusb.h
# Then I could start compilation of rtlsdr
git clone git://git.osmocom.org/rtl-sdr.git
cd rtl-sdr/
mkdir build
cd build
# The lib dir is for odroid-u3 weirdness. The _FILE_OFFSET_BITS is for writing >2GB files without pipes.
cmake ../ -DCMAKE_INSTALL_PREFIX=/usr -DINSTALL_UDEV_RULES=ON -DLIB_DIR=/usr/lib/arm-linux-gnueabihf -D_FILE_OFFSET_BITS=64
make
sudo make install
sudo su -
ldconfig

#hackrf one on odroid-u3, do all the non-rtlsdr stuff above then,
git clone git://github.com/mossmann/hackrf.git
cd hackrf/host
mkdir build
cd build
# The lib dir is for odroid-u3 weirdness. The _FILE_OFFSET_BITS is for writing >2GB files without pipes.
cmake ../ -DINSTALL_UDEV_RULES=ON -DLIB_DIR=/usr/lib/arm-linux-gnueabihf -D_FILE_OFFSET_BITS=64
make
sudo make install
sudo su -
ldconfig
</pre>

<!--
<hr />
<h5>Spectrum Machine...</h5>
<img src="/spectrummachine.png" />
<img src="http://www.google.com/?q=tails+usb" />
-->

<hr />

<h5>2020-01-14: This change is just to trigger change detection bots. Bork bork bork.</h5>

		<link rel="webmention" href="http://superkuh.com/webmention" >
		<p style="font-size: 0.75em; margin-bottom: 0.2em;margin-top: 0.2em;"><b>[<a href="/hello/?posted">comment</a> on this post]</b> Append "/<b>@say</b>/your message here" to the URL in the location bar and hit enter.</p>
		<form action="/webmention" method="POST">
  		<p style="font-size: 0.75em; margin-bottom: 0.2em;margin-top: 0.2em;"><b>[webmention/pingback]</b> Did you respond to this URL? What's your URL? <input type="text" name="source" value="http://yoursite.net/response"><input type="submit" value="send">
  		<input name="target" value="http://superkuh.com/rtlsdr.html" type="hidden"></p>
		</form>



</div>

	<div id="left" class="column">

		<a href="/"><img src="/tech_avatar.jpeg"/></a>	

		<h4>Related Pages</h4>
		<ul class="navlist">
		<li><a href="/rtlsdr.html">RTLSDR/GNU Radio</a>
<!--			<ul class="navlist">
			<li><a href="http://erewhon.superkuh.com/gnuradio/live/">(Not)Live Frequency Monitor</a></li>
			</ul>
-->
		</li>


		<li><a href="http://superkuh.com/radio/">70-1000 MHz Radio Archive</a>
			<ul class="navlist">
			<li>Frequency hopping scans, directory list, an <a href="http://www.superkuh.com/radio/2014-12-07_06-39_70-1000_32k/">example</a>.</li>
			</ul>
		</li>


		<li><a href="/rtlsdrinterferometer.html">11 GHz Interferometer</a>
			<ul class="navlist">
			<li><a href="/library/Space/Radio%20Astronomy/">Resources</a></li>
			</ul>
		</li>
<!--
		<li><a href="/spiralantenna.html">Spiral Antenna</a>
			<ul class="navlist">
			<li><a href="/library/Electromagnetics/Spiral%20Antenna/">Resources</a></li>
			</ul>
		</li>
-->
		<li><a href="/thisurlnamehasnothingtodowiththeactualtopicijustnameditthisforkicks.html">Broadband Antenna</a>
<!--			<ul class="navlist">
			<li><a href="/library/Electromagnetics/">Resources</a></li>
			</ul>
-->
		</li>

		<li>Planar PCB Radio Filters<ul class="navlist">
			<li><a href="/radio-filter-simulations.html">Dual-Coupled Combline Bandstop</a></li>
			<li><a href="/stepped-impedance-bandstop-filter.html">Stepped Impedance Bandstop</a></li>
			<li><a href="/dgs-bandpass-filter.html">Defected Ground Structure Open-Loop and Split-Ring Resonator Bandpasses</a></li>
			<li><a href="/tunable-open-loop-bandpass-filters.html">Tunable Open-Loop Resonator Bandpass</a></li>
			<li><a href="/tunable-combline-bandpass-filters.html">Tunable Combline Bandpass</a></li>
			<li><a href="/siw-coaxial-cavity-bandpass.html">Substrated Integrated Waveguide Coaxial Cavity Bandpass</a></li>
			</ul>

		</li>

		</ul>



<!--
		<h4>Spaceweather</h4>
		<ul class="navlist">
		
		<li><a href="http://erewhon.superkuh.com/spaceweather/">Aggregator</a>
			<ul class="navlist">
			<li><a href="http://erewhon.superkuh.com/spaceweather/load.html">&lt;Load only on Scroll&gt;</a></li>
			<li><a href="http://erewhon.superkuh.com/spaceweather/quicklook.html">Quicklook</li>
			<li><a href="http://erewhon.superkuh.com/spaceweather/heliosphere.html">Heliosphere/Magnetosphere</li>
			<li><a href="http://erewhon.superkuh.com/spaceweather/lightandparticle.html">Light/Particle fluxes</li>
			<li><a href="http://erewhon.superkuh.com/spaceweather/irradiancetrends.html">Irradiance and Trends</li>
			<li><a href="http://erewhon.superkuh.com/spaceweather/radio.html">Radio</li>
			<li><a href="http://erewhon.superkuh.com/spaceweather/geomagnetic.html">Geomagnetic</li>
			<li><a href="http://erewhon.superkuh.com/spaceweather/geomagnetic2.html">Geomagnetic 2</li>
			<li><a href="http://erewhon.superkuh.com/spaceweather/solarmagnetic.html">Solar Magnetic/Spots</li>
			<li><a href="http://erewhon.superkuh.com/spaceweather/solardisk.html">Solar Disk/Corona Imaging</li>
			<li><a href="http://erewhon.superkuh.com/spaceweather/sdoaia.html">SDO AIA and HMI</li>
			<li><a href="http://erewhon.superkuh.com/spaceweather/unsorted.html">Unsorted</a></li>
			</ul>		
		</li>

		<li>Source Code
			<ul class="navlist">
			<li><a href="/spaceweather.pl">spaceweather.pl</a></li>
			<li><a href="/spaceweather_oncedaily.pl">spaceweather_oncedaily.pl</a></li>
			<li><a href="/arforecastmovie.pl">arforecastmovie.pl</a></li>
			<li><a href="/solisarmirror.pl">solisarmirror.pl</a></li>
			</ul>
		</li>

		<li><a href="/solarandspaceweather.html">Links</a></li>
		<li><a href="/library/Space/Solar">Resources</a></li>
		</ul>
-->

<!-- START RTLSDR MENU -->
<div style="font-size:x-small;margin-left:0px;">
<h3>Page Sections</h3>
<ul style="padding-left:4px;">
<li>Intro (here)</li>
<li><a href="#hardware">Hardware</a>
	<ul><li><a href="#tuners">Tuners</a>
	
		<ul>
		<li><a href="#tuners.retunespeed">re-tune speed</a></li>
		<li><a href="#tuners.tuningrange">frequency range</a></li>
		<li><a href="#tuners.gain">gain</a></li>
		<li><a href="#tuners.frequencyerror">frequency error</a></li>
		<li><a href="#tuners.r820t2">R280T2</a></li>
		<li><a href="#tuners.r820tiffilter">R820T/T2 IF Filter</a></li>
		<li><a href="#tuners.r828d">R828D</a></li>
		<!--<li><a href="#tuners.fc0013">dual FC0013</a></li>-->
		</ul>

	</li>
	<li><a href="#directsample">Direct Sample Mode</a></li>
	<li><a href="#noise">Noise/RFI</a></li>
	<li><a href="#clocks">Clocks</a>

	<ul>
	<li><a href="#clocks">Shared Clocks</a></li>
	<li><a href="#clocks.align">Maintaining Coherency</a></li>
	<li><a href="#clocks.dithering">PLL Dithering</a></li>
	</ul>

	</li>
	<li><a href="#broadbandantenna">Broadband Antenna</a></li>
	</ul>
</li>
<li><a href="#links">Links/Datasheets</a></li>
<li><a href="#installing">Installing RTLSDR and GNU Radio</a></li>
<li><a href="#appnotes">RTLSDR Applications Notes</a>
	<ul>
	<li><a href="#keenerdappnote">keenerd's branch</a></li>
	<li><a href="#multimodeappnote">Multimode</a></li>
	<li><a href="#gqrxappnote">Gqrx</a></li>
	<li><a href="#sdrsharpappnote">SDR#</a></li>
	<li><a href="#grfosphor">gr-fosphor</a></li>
	<li><a href="#adbssharpappnote">ADBS#</a></li>
	<li><a href="#grairmodesappnote">gr-air-modes</a></li>
	<li><a href="#dump1090appnote">Dump1090</a></li>
	<li><a href="#linradappnote">gr-air-modes</a></li>
	<li><a href="#ltecellappnote">LTE Cell Scanner</a></li>
	<li><a href="#kalibrateappnote">kalibrate-rtl</a></li>
	<li><a href="#simplefmappnote">simple_fm</a></li>
	<li><a href="#simple_ra">simple radio astronomy</a></li>
	<li><a href="#rtlsdrscannerappnote">RTLSDR Scanner</a></li>
	<li><a href="#dongleloggerappnote">Dongle Logger</a></li>
	</ul>
</li>
<li><a href="#pager">Pagers</a></li>
<li><a href="#gqrx">Gqrx on Ubuntu 10.04</a></li>
<li><a href="#ltescanner">LTE Scanner on Ubuntu 10.04</a></li>
<li><a href="#grc">GNU Radio Companion</a></li>
<li><a href="#odroid">odroid-u3 rtlsdr</a></li>
<li>Stuff I made
<ul>
<li><a href="#pyrtlsdr_logger">Wideband Scanning Spectrograms</a></li>
<li><a href="#interferometer">11 GHz Interferometer</a></li>
</ul>


</ul>

<p>Type, "/@say/Your message here." after the end of <em>any URL</em> on my site and hit enter to leave a comment. You can <a href="/hello/">view them here.</a> An example would be, http://superkuh.com/rtlsdr.html/@say/This is a comment.</p>

</div>
<!-- END RTLSDR MENU -->


	</div>


		<!-- <li><a href="/processactogram.pl">ProcessActogram</a>
			<ul class="navlist">Generates a color coded activity graph of which xwindows were focused/being used at any given second of the day. A visualization of what you do on your graphical shell.</ul></li> -->
		<!-- <li>xchat2megahal</li> -->
		<!--<li><a href="/zoneplate.pl">zoneplate.pl</a></li>-->

<!-- This is a link for search enginers that parse comments.
<a href="/cuttingprecisecoaxlengths.html">Cutting Precise Coax Lengths</a> mirror
-->


<div id="right" class="column">

</div>

</body>
</html>

